{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DiRAC Extreme Scaling User Documentation DiRAC Extreme Scaling is part of the DiRAC National HPC Service . You can find more information on the service and the research it supports on the DiRAC website . The DiRAC Extreme Scaling service is an HPC resource for UK researchers. DiRAC Extreme Scaling is provided by UKRI , EPCC and the University of Edinburgh . The hardware is provided by HPE and ATOS . DiRAC Extreme Scaling currently provides two HPC resources: Tesseract: a CPU-based system provided by HPE. Tursa: a GPU-based system provided by ATOS. What the documentation covers This is the documentation for the ARCHER2 service and includes: Tesseract User Guide Covers all aspects of use of the Tesseract resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa, and other advanced technical topics. Tursa User Guide Covers all aspects of use of the Tursa resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa, and other advanced technical topics. Contributing to the documentation The source for this documentation is publicly available in the DiRAC Extreme Scaling documentation Github repository so that anyone can contribute to improve the documentation for the service. Contributions can be in the form of improvements or addtions to the content and/or addtion of Issues providing suggestions for how it can be improved. Full details of how to contribute can be found in the README.md file of the repository.","title":"Documentation overview"},{"location":"#dirac-extreme-scaling-user-documentation","text":"DiRAC Extreme Scaling is part of the DiRAC National HPC Service . You can find more information on the service and the research it supports on the DiRAC website . The DiRAC Extreme Scaling service is an HPC resource for UK researchers. DiRAC Extreme Scaling is provided by UKRI , EPCC and the University of Edinburgh . The hardware is provided by HPE and ATOS . DiRAC Extreme Scaling currently provides two HPC resources: Tesseract: a CPU-based system provided by HPE. Tursa: a GPU-based system provided by ATOS.","title":"DiRAC Extreme Scaling User Documentation"},{"location":"#what-the-documentation-covers","text":"This is the documentation for the ARCHER2 service and includes: Tesseract User Guide Covers all aspects of use of the Tesseract resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa, and other advanced technical topics. Tursa User Guide Covers all aspects of use of the Tursa resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa, and other advanced technical topics.","title":"What the documentation covers"},{"location":"#contributing-to-the-documentation","text":"The source for this documentation is publicly available in the DiRAC Extreme Scaling documentation Github repository so that anyone can contribute to improve the documentation for the service. Contributions can be in the form of improvements or addtions to the content and/or addtion of Issues providing suggestions for how it can be improved. Full details of how to contribute can be found in the README.md file of the repository.","title":"Contributing to the documentation"},{"location":"tesseract-user-guide/","text":"Tesseract User Guide The Tesseract User Guide covers all aspects of use of the Tesseract resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa and more technical topics. The Tesseract User Guide is currently hosted on a separate website: Tesseract User Guide","title":"Overview"},{"location":"tesseract-user-guide/#tesseract-user-guide","text":"The Tesseract User Guide covers all aspects of use of the Tesseract resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa and more technical topics. The Tesseract User Guide is currently hosted on a separate website: Tesseract User Guide","title":"Tesseract User Guide"},{"location":"tursa-user-guide/","text":"Tursa User Guide The Tursa User Guide covers all aspects of use of the Tursa resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa and more technical topics. The Tursa User Guide contains the following sections: Connecting to Tursa Data management and transfer Software environment Running jobs on Tursa","title":"Overview"},{"location":"tursa-user-guide/#tursa-user-guide","text":"The Tursa User Guide covers all aspects of use of the Tursa resource. This includes fundamentals (required by all users to use the system effectively), best practice for getting the most out of Tursa and more technical topics. The Tursa User Guide contains the following sections: Connecting to Tursa Data management and transfer Software environment Running jobs on Tursa","title":"Tursa User Guide"},{"location":"tursa-user-guide/connecting/","text":"Connecting to Tursa On the Tursa system, interactive access can be achieved via SSH, either directly from a command line terminal or using an SSH client. In addition data can be transferred to and from the Tursa system using scp from the command line or by using a file transfer client. This section covers the basic connection methods. Before following the process below, we assume you have setup an account on Tursa through the DiRAC SAFE. Documentation on how to do this can be found at: DiRAC SAFE Guide for Users Command line terminal Linux Linux distributions come installed with a terminal application that can be used for SSH access to the login nodes. Linux users will have different terminals depending on their distribution and window manager (e.g. GNOME Terminal in GNOME, Konsole in KDE). Consult your Linux distribution's documentation for details on how to load a terminal. MacOS MacOS users can use the Terminal application, located in the Utilities folder within the Applications folder. Windows A typical Windows installation will not include a terminal client, though there are various clients available. We recommend all our Windows users to download and install MobaXterm to access Tursa. It is very easy to use and includes an integrated X server with SSH client to run any graphical applications on Tursa. You can download MobaXterm Home Edition (Installer Edition) from the following link: Install MobaXterm Double-click the downloaded Microsoft Installer file (.msi), and the Windows wizard will automatically guides you through the installation process. Note, you might need to have administrator rights to install on some Windows OS. Also make sure to check whether Windows Firewall hasn't blocked any features of this program after installation. Start MobaXterm and then click \"Start local terminal\" Tips If you download the .zip file rather than the .msi, make sure you unzip before attempting to run the installer. If you are using a \"managed desktop\" machine, so do not have admin rights, you can use the Portable edition of MobaXterm which doesn't need install privilages. If this is your first time using MobaXterm, check that a permanent /home directory has been set up (or all saved info will be lost from session to session). Go to \"Settings\" -> \"Configuration\"-> check path to \"Persistent home directory\" is set and make sure path is \"private\" if prompted. Any ssh key generated in MobaXterm will, by default, be stored in the permanent /home directory (see above) i.e. if your /home directory is _MyDocuments_\\MobaXterm\\home then within that folder you will find _MyDocuments_\\MobaXterm\\home\\.ssh with your keys. This folder will be 'hidden' by default so you may need to tick 'Hidden items' under 'View' in Windows Explorer to see it. MobaXterm also allows you to set up ssh sessions with the username, login host and key details saved. You are welcome to use this, rather than using the \"Local terminal\" but we are not able to assist with debugging connection issues if you choose this method. We recommend sticking to command line terminal access. Access credentials To access Tursa, you need to use two credentials: your password and an SSH key pair protected by a passphrase. You can find more detailed instructions on how to set up your credentials to access Tursa from Windows, macOS and Linux below. SSH Key Pairs You will need to generate an SSH key pair protected by a passphrase to access Tursa. Using a terminal (the command line), set up a key pair that contains your e-mail address and enter a passphrase you will use to unlock the key: $ ssh-keygen -t rsa -C \"your@email.com\" ... -bash-4.1$ ssh-keygen -t rsa -C \"your@email.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Home/user/.ssh/id_rsa): [Enter] Enter passphrase (empty for no passphrase): [Passphrase] Enter same passphrase again: [Passphrase] Your identification has been saved in /Home/user/.ssh/id_rsa. Your public key has been saved in /Home/user/.ssh/id_rsa.pub. The key fingerprint is: 03:d4:c4:6d:58:0a:e2:4a:f8:73:9a:e8:e3:07:16:c8 your@email.com The key's randomart image is: +--[ RSA 2048]----+ | . ...+o++++. | | . . . =o.. | |+ . . .......o o | |oE . . | |o = . S | |. +.+ . | |. oo | |. . | | .. | +-----------------+ (remember to replace \"your@email.com\" with your e-mail address). Upload public part of key pair to SAFE You should now upload the public part of your SSH key pair to the SAFE by following the instructions at: Login to SAFE . Then: Go to the Menu Login accounts and select the Tursa account you want to add the SSH key to On the subsequent Login account details page click the Add Credential button Select SSH public key as the Credential Type and click Next Either copy and paste the public part of your SSH key into the SSH Public key box or use the button to select the public key file on your computer. Click Add to associate the public SSH key part with your account Once you have done this, your SSH key will be added to your Tursa account. Remember, you will need to use both an SSH key and password to log into Tursa so you will also need to collect your initial password before you can log into Tursa. We cover this next. Note If you want to connect to Tursa from more than one machine, e.g. from your home laptop as well as your work laptop, you should generate an ssh key on each machine, and add each of the public keys into SAFE. Initial passwords The SAFE web interface is used to provide your initial password for logging onto Tursa (see the SAFE Documentation for more details on requesting accounts and picking up passwords). Note You may now change your password on the Tursa machine itself using the passwd command or when you are prompted the first time you login. This change will not be reflected in the SAFE. If you forget your password, you should use the SAFE to request a new one-shot password. SSH Clients Interaction with Tursa is done remotely, over an encrypted communication channel, Secure Shell version 2 (SSH-2). This allows command-line access to one of the login nodes of a Tursa, from which you can run commands or use a command-line text editor to edit files. SSH can also be used to run graphical programs such as GUI text editors and debuggers when used in conjunction with an X client. Logging in You can use the following command from the terminal window to login into Tursa: ssh username@tursa.dirac.ed.ac.uk You will first be prompted for your machine account password. Once you have entered your password successfully, you will then be prompted for the passphrase associated with your SSH key pair. You need to enter both credentials correctly to be able to access Tursa. Tip If your SSH key pair is not stored in the default location (usually ~/.ssh/id_rsa ) on your local system, you may need to specify the path to the private part of the key wih the -i option to ssh . For example, if your key is in a file called keys/id_rsa_Tursa you would use the command ssh -i keys/id_rsa_Tursa username@login.tursa.ac.uk to log in. Tip When you first log into Tursa, you will be prompted to change your initial password. This is a three step process: When promoted to enter your ldap password : Re-enter the password you retrieved from SAFE When prompted to enter your new password: type in a new password When prompted to re-enter the new password: re-enter the new password Your password has now been changed To allow remote programs, especially graphical applications to control your local display, such as being able to open up a new GUI window (such as for a debugger), use: ssh -X username@tursa.dirac.ed.ac.uk Some sites recommend using the -Y flag. While this can fix some compatibility issues, the -X flag is more secure. Current MacOS systems do not have an X window system. Users should install the XQuartz package to allow for SSH with X11 forwarding on MacOS systems: XQuartz website Making access more convenient using the SSH configuration file Typing in the full command to login or transfer data to Tursa can become tedious as it often has to be repeated many times. You can use the SSH configuration file, usually located on your local machine at .ssh/config to make things a bit more convenient. Each remote site (or group of sites) can have an entry in this file which may look something like: Host tursa HostName tursa.dirac.ed.ac.uk User username (remember to replace username with your actual username!). The Host tursa line defines a short name for the entry. In this case, instead of typing ssh username@tursa.dirac.ed.ac.uk to access the Tursa login nodes, you could use ssh tursa instead. The remaining lines define the options for the tursa host. Hostname tursa.dirac.ed.ac.uk - defines the full address of the host User username - defines the username to use by default for this host (replace username with your own username on the remote host) Now you can use SSH to access Tursa without needing to enter your username or the full hostname every time: $ ssh tursa You can set up as many of these entries as you need in your local configuration file. Other options are available. See the ssh_config man page (or man ssh_config on any machine with SSH installed) for a description of the SSH configuration file. You may find the IdentityFile option useful if you have to manage multiple SSH key pairs for different systems as this allows you to specify which SSH key to use for each system. Bug There is a known bug with Windows ssh-agent. If you get the error message: Warning: agent returned different signature type ssh-rsa (expected rsa-sha2-512) , you will need to either specify the path to your ssh key in the command line (using the -i option as described above) or add the path to your SSH config file by using the IdentityFile option. SSH debugging tips If you find you are unable to connect via SSH there are a number of ways you can try and diagnose the issue. Some of these are collected below - if you are having difficulties connecting we suggest trying these before contacting the Tursa service desk. Use the user@tursa.dirac.ed.ac.uk syntax rather than -l user tursa.dirac.ed.ac.uk We have seen a number of instances where people using the syntax ssh -l user tursa.dirac.ed.ac.uk have not been able to connect properly and get prompted for a password many times. We have found that using the alternative syntax: ssh user@tursa.dirac.ed.ac.uk works more reliably. If you are using the -l user option to connect and are seeing issues, then try using user@tursa.dirac.ed.ac.uk instead. Can you connect to the login node? Try the command ping -c 3 tursa.dirac.ed.ac.uk . If you successfully connect to the login node, the output should include: --- tursa.dirac.ed.ac.uk ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 38ms (the ping time '38ms' is not important). If not all packets are received there could be a problem with your internet connection, or the login node could be unavailable. Password If you are having trouble entering your password consider using a password manager, from which you can copy and paste it. This will also help you generate a secure password. If you need to reset your password, instructions for doing so can be found in the SAFE documentation Windows users please note that Ctrl+V does not work to paste in to PuTTY, MobaXterm, or PowerShell. Instead use Shift+Ins to paste. Alternatively, right-click and select 'Paste' in PuTTY and MobaXterm, or simply right-click to paste in PowerShell. SSH key If you get the error message Permission denied (publickey) this can indicate a problem with your SSH key. Some things to check: Have you uploaded the key to SAFE? Please note that if the same key is reuploaded SAFE will not map the \"new\" key to Tursa. If for some reason this is required, please delete the key first, then reupload. Is ssh using the correct key? You can check which keys are being found and offered by ssh using ssh -vvv . If your private key has a non-default name you can use the -i flag to provide it to ssh, i.e. ssh -i path/to/key username@tursa.dirac.ed.ac.uk . Are you entering the passphrase correctly? You will be asked for your private key's passphrase first. If you enter it incorrectly you will usually be asked to enter it again, and usually up to three times in total, after which ssh will fail with Permission denied (publickey) . If you would like to confirm your passphrase without attempting to connect, you can use ssh-keygen -y -f /path/to/private/key . If successful, this command will print the corresponding public key. You can also use this to check it is the one uploaded to SAFE. Are permissions correct on the ssh key? One common issue is that the permissions are incorrect on the either the key file, or the directory it's contained in. On Linux/MacOS for example, if your private keys are held in ~/.ssh/ you can check this with ls -al ~/.ssh . This should give something similar to the following output: $ ls -al ~/.ssh/ drwx------. 2 user group 48 Jul 15 20:24 . drwx------. 12 user group 4096 Oct 13 12:11 .. -rw-------. 1 user group 113 Jul 15 20:23 authorized_keys -rw-------. 1 user group 12686 Jul 15 20:23 id_rsa -rw-r--r--. 1 user group 2785 Jul 15 20:23 id_rsa.pub -rw-r--r--. 1 user group 1967 Oct 13 14:11 known_hosts The important section here is the string of letters and dashes at the start, for the lines ending in . , id_rsa , and id_rsa.pub , which indicate permissions on the containing directory, private key, and public key respectively. If your permissions are not correct, they can be set with chmod . Consult the table below for the relevant chmod command. On Windows, permissions are handled differently but can be set by right-clicking on the file and selecting Properties > Security > Advanced. The user, SYSTEM, and Administrators should have Full control , and no other permissions should exist for both public and private key files, and the containing folder. Target Permissions chmod Code Directory drwx------ 700 Private Key -rw------- 600 Public Key -rw-r--r-- 644 chmod can be used to set permissions on the target in the following way: chmod <code> <target> . So for example to set correct permissions on the private key file id_rsa_Tursa one would use the command chmod 600 id_rsa_Tursa . Tip Unix file permissions can be understood in the following way. There are three groups that can have file permissions: (owning) users , (owning) groups , and others . The available permissions are read , write , and execute . The first character indicates whether the target is a file - , or directory d . The next three characters indicate the owning user's permissions. The first character is r if they have read permission, - if they don't, the second character is w if they have write permission, - if they don't, the third character is x if they have execute permission, - if they don't. This pattern is then repeated for group , and other permissions. For example the pattern -rw-r--r-- indicates that the owning user can read and write the file, members of the owning group can read it, and anyone else can also read it. The chmod codes are constructed by treating the user, group, and owner permission strings as binary numbers, then converting them to decimal. For example the permission string -rwx------ becomes 111 000 000 -> 700 . SSH verbose output Verbose debugging output from ssh can be very useful for diagnosing the issue. In particular, it can be used to distinguish between problems with the SSH key and password - further details are given below. To enable verbose output add the -vvv flag to your SSH command. For example: ssh -vvv username@tursa.dirac.ed.ac.uk The output is lengthy, but somewhere in there you should see lines similar to the following: debug1: Next authentication method: keyboard-interactive debug2: userauth_kbdint debug3: send packet: type 50 debug2: we sent a keyboard-interactive packet, wait for reply debug3: receive packet: type 60 debug2: input_userauth_info_req debug2: input_userauth_info_req: num_prompts 1 Password: debug3: send packet: type 61 debug3: receive packet: type 60 debug2: input_userauth_info_req debug2: input_userauth_info_req: num_prompts 0 debug3: send packet: type 61 debug3: receive packet: type 51 Authenticated with partial success. debug1: Authentications that can continue: publickey,password If you do not see the Password: prompt you may have connection issues, or there could be a problem with the Tursa login nodes. If you do not see Authenticated with partial success it means your password was not accepted. You will be asked to re-enter your password, usually two more times before the connection will be rejected. Consider the suggestions under Password above. If you do see Authenticated with partial success , it means your password was accepted, and your SSH key will now be checked. You should next see something similiar to: debug1: Next authentication method: publickey debug1: Offering public key: RSA SHA256:<key_hash> <path_to_private_key> debug3: send_pubkey_test debug3: send packet: type 50 debug2: we sent a publickey packet, wait for reply debug3: receive packet: type 60 debug1: Server accepts key: pkalg rsa-sha2-512 blen 2071 debug2: input_userauth_pk_ok: fp SHA256:<key_hash> debug3: sign_and_send_pubkey: RSA SHA256:<key_hash> Enter passphrase for key '<path_to_private_key>': debug3: send packet: type 50 debug3: receive packet: type 52 debug1: Authentication succeeded (publickey). Most importantly, you can see which files ssh has checked for private keys, and you can see if any key is accepted. The line Authenticated succeeded indicates that the SSH key has been accepted. By default ssh will go through a list of standard private key files, as well as any you have specified with -i or a config file. This is fine, as long as one of the files mentioned is the one that matches the public key uploaded to SAFE. If your SSH key passphrase is incorrect, you will be asked to try again up to three times in total, before being disconnected with Permission denied (publickey) . If you enter your passphrase correctly, but still see this error message, please consider the advice under SSH key above.","title":"Connecting to Tursa"},{"location":"tursa-user-guide/connecting/#connecting-to-tursa","text":"On the Tursa system, interactive access can be achieved via SSH, either directly from a command line terminal or using an SSH client. In addition data can be transferred to and from the Tursa system using scp from the command line or by using a file transfer client. This section covers the basic connection methods. Before following the process below, we assume you have setup an account on Tursa through the DiRAC SAFE. Documentation on how to do this can be found at: DiRAC SAFE Guide for Users","title":"Connecting to Tursa"},{"location":"tursa-user-guide/connecting/#command-line-terminal","text":"","title":"Command line terminal"},{"location":"tursa-user-guide/connecting/#linux","text":"Linux distributions come installed with a terminal application that can be used for SSH access to the login nodes. Linux users will have different terminals depending on their distribution and window manager (e.g. GNOME Terminal in GNOME, Konsole in KDE). Consult your Linux distribution's documentation for details on how to load a terminal.","title":"Linux"},{"location":"tursa-user-guide/connecting/#macos","text":"MacOS users can use the Terminal application, located in the Utilities folder within the Applications folder.","title":"MacOS"},{"location":"tursa-user-guide/connecting/#windows","text":"A typical Windows installation will not include a terminal client, though there are various clients available. We recommend all our Windows users to download and install MobaXterm to access Tursa. It is very easy to use and includes an integrated X server with SSH client to run any graphical applications on Tursa. You can download MobaXterm Home Edition (Installer Edition) from the following link: Install MobaXterm Double-click the downloaded Microsoft Installer file (.msi), and the Windows wizard will automatically guides you through the installation process. Note, you might need to have administrator rights to install on some Windows OS. Also make sure to check whether Windows Firewall hasn't blocked any features of this program after installation. Start MobaXterm and then click \"Start local terminal\" Tips If you download the .zip file rather than the .msi, make sure you unzip before attempting to run the installer. If you are using a \"managed desktop\" machine, so do not have admin rights, you can use the Portable edition of MobaXterm which doesn't need install privilages. If this is your first time using MobaXterm, check that a permanent /home directory has been set up (or all saved info will be lost from session to session). Go to \"Settings\" -> \"Configuration\"-> check path to \"Persistent home directory\" is set and make sure path is \"private\" if prompted. Any ssh key generated in MobaXterm will, by default, be stored in the permanent /home directory (see above) i.e. if your /home directory is _MyDocuments_\\MobaXterm\\home then within that folder you will find _MyDocuments_\\MobaXterm\\home\\.ssh with your keys. This folder will be 'hidden' by default so you may need to tick 'Hidden items' under 'View' in Windows Explorer to see it. MobaXterm also allows you to set up ssh sessions with the username, login host and key details saved. You are welcome to use this, rather than using the \"Local terminal\" but we are not able to assist with debugging connection issues if you choose this method. We recommend sticking to command line terminal access.","title":"Windows"},{"location":"tursa-user-guide/connecting/#access-credentials","text":"To access Tursa, you need to use two credentials: your password and an SSH key pair protected by a passphrase. You can find more detailed instructions on how to set up your credentials to access Tursa from Windows, macOS and Linux below.","title":"Access credentials"},{"location":"tursa-user-guide/connecting/#ssh-key-pairs","text":"You will need to generate an SSH key pair protected by a passphrase to access Tursa. Using a terminal (the command line), set up a key pair that contains your e-mail address and enter a passphrase you will use to unlock the key: $ ssh-keygen -t rsa -C \"your@email.com\" ... -bash-4.1$ ssh-keygen -t rsa -C \"your@email.com\" Generating public/private rsa key pair. Enter file in which to save the key (/Home/user/.ssh/id_rsa): [Enter] Enter passphrase (empty for no passphrase): [Passphrase] Enter same passphrase again: [Passphrase] Your identification has been saved in /Home/user/.ssh/id_rsa. Your public key has been saved in /Home/user/.ssh/id_rsa.pub. The key fingerprint is: 03:d4:c4:6d:58:0a:e2:4a:f8:73:9a:e8:e3:07:16:c8 your@email.com The key's randomart image is: +--[ RSA 2048]----+ | . ...+o++++. | | . . . =o.. | |+ . . .......o o | |oE . . | |o = . S | |. +.+ . | |. oo | |. . | | .. | +-----------------+ (remember to replace \"your@email.com\" with your e-mail address).","title":"SSH Key Pairs"},{"location":"tursa-user-guide/connecting/#upload-public-part-of-key-pair-to-safe","text":"You should now upload the public part of your SSH key pair to the SAFE by following the instructions at: Login to SAFE . Then: Go to the Menu Login accounts and select the Tursa account you want to add the SSH key to On the subsequent Login account details page click the Add Credential button Select SSH public key as the Credential Type and click Next Either copy and paste the public part of your SSH key into the SSH Public key box or use the button to select the public key file on your computer. Click Add to associate the public SSH key part with your account Once you have done this, your SSH key will be added to your Tursa account. Remember, you will need to use both an SSH key and password to log into Tursa so you will also need to collect your initial password before you can log into Tursa. We cover this next. Note If you want to connect to Tursa from more than one machine, e.g. from your home laptop as well as your work laptop, you should generate an ssh key on each machine, and add each of the public keys into SAFE.","title":"Upload public part of key pair to SAFE"},{"location":"tursa-user-guide/connecting/#initial-passwords","text":"The SAFE web interface is used to provide your initial password for logging onto Tursa (see the SAFE Documentation for more details on requesting accounts and picking up passwords). Note You may now change your password on the Tursa machine itself using the passwd command or when you are prompted the first time you login. This change will not be reflected in the SAFE. If you forget your password, you should use the SAFE to request a new one-shot password.","title":"Initial passwords"},{"location":"tursa-user-guide/connecting/#ssh-clients","text":"Interaction with Tursa is done remotely, over an encrypted communication channel, Secure Shell version 2 (SSH-2). This allows command-line access to one of the login nodes of a Tursa, from which you can run commands or use a command-line text editor to edit files. SSH can also be used to run graphical programs such as GUI text editors and debuggers when used in conjunction with an X client.","title":"SSH Clients"},{"location":"tursa-user-guide/connecting/#logging-in","text":"You can use the following command from the terminal window to login into Tursa: ssh username@tursa.dirac.ed.ac.uk You will first be prompted for your machine account password. Once you have entered your password successfully, you will then be prompted for the passphrase associated with your SSH key pair. You need to enter both credentials correctly to be able to access Tursa. Tip If your SSH key pair is not stored in the default location (usually ~/.ssh/id_rsa ) on your local system, you may need to specify the path to the private part of the key wih the -i option to ssh . For example, if your key is in a file called keys/id_rsa_Tursa you would use the command ssh -i keys/id_rsa_Tursa username@login.tursa.ac.uk to log in. Tip When you first log into Tursa, you will be prompted to change your initial password. This is a three step process: When promoted to enter your ldap password : Re-enter the password you retrieved from SAFE When prompted to enter your new password: type in a new password When prompted to re-enter the new password: re-enter the new password Your password has now been changed To allow remote programs, especially graphical applications to control your local display, such as being able to open up a new GUI window (such as for a debugger), use: ssh -X username@tursa.dirac.ed.ac.uk Some sites recommend using the -Y flag. While this can fix some compatibility issues, the -X flag is more secure. Current MacOS systems do not have an X window system. Users should install the XQuartz package to allow for SSH with X11 forwarding on MacOS systems: XQuartz website","title":"Logging in"},{"location":"tursa-user-guide/connecting/#making-access-more-convenient-using-the-ssh-configuration-file","text":"Typing in the full command to login or transfer data to Tursa can become tedious as it often has to be repeated many times. You can use the SSH configuration file, usually located on your local machine at .ssh/config to make things a bit more convenient. Each remote site (or group of sites) can have an entry in this file which may look something like: Host tursa HostName tursa.dirac.ed.ac.uk User username (remember to replace username with your actual username!). The Host tursa line defines a short name for the entry. In this case, instead of typing ssh username@tursa.dirac.ed.ac.uk to access the Tursa login nodes, you could use ssh tursa instead. The remaining lines define the options for the tursa host. Hostname tursa.dirac.ed.ac.uk - defines the full address of the host User username - defines the username to use by default for this host (replace username with your own username on the remote host) Now you can use SSH to access Tursa without needing to enter your username or the full hostname every time: $ ssh tursa You can set up as many of these entries as you need in your local configuration file. Other options are available. See the ssh_config man page (or man ssh_config on any machine with SSH installed) for a description of the SSH configuration file. You may find the IdentityFile option useful if you have to manage multiple SSH key pairs for different systems as this allows you to specify which SSH key to use for each system. Bug There is a known bug with Windows ssh-agent. If you get the error message: Warning: agent returned different signature type ssh-rsa (expected rsa-sha2-512) , you will need to either specify the path to your ssh key in the command line (using the -i option as described above) or add the path to your SSH config file by using the IdentityFile option.","title":"Making access more convenient using the SSH configuration file"},{"location":"tursa-user-guide/connecting/#ssh-debugging-tips","text":"If you find you are unable to connect via SSH there are a number of ways you can try and diagnose the issue. Some of these are collected below - if you are having difficulties connecting we suggest trying these before contacting the Tursa service desk.","title":"SSH debugging tips"},{"location":"tursa-user-guide/connecting/#use-the-usertursadiracedacuk-syntax-rather-than-l-user-tursadiracedacuk","text":"We have seen a number of instances where people using the syntax ssh -l user tursa.dirac.ed.ac.uk have not been able to connect properly and get prompted for a password many times. We have found that using the alternative syntax: ssh user@tursa.dirac.ed.ac.uk works more reliably. If you are using the -l user option to connect and are seeing issues, then try using user@tursa.dirac.ed.ac.uk instead.","title":"Use the user@tursa.dirac.ed.ac.uk syntax rather than -l user tursa.dirac.ed.ac.uk"},{"location":"tursa-user-guide/connecting/#can-you-connect-to-the-login-node","text":"Try the command ping -c 3 tursa.dirac.ed.ac.uk . If you successfully connect to the login node, the output should include: --- tursa.dirac.ed.ac.uk ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 38ms (the ping time '38ms' is not important). If not all packets are received there could be a problem with your internet connection, or the login node could be unavailable.","title":"Can you connect to the login node?"},{"location":"tursa-user-guide/connecting/#password","text":"If you are having trouble entering your password consider using a password manager, from which you can copy and paste it. This will also help you generate a secure password. If you need to reset your password, instructions for doing so can be found in the SAFE documentation Windows users please note that Ctrl+V does not work to paste in to PuTTY, MobaXterm, or PowerShell. Instead use Shift+Ins to paste. Alternatively, right-click and select 'Paste' in PuTTY and MobaXterm, or simply right-click to paste in PowerShell.","title":"Password"},{"location":"tursa-user-guide/connecting/#ssh-key","text":"If you get the error message Permission denied (publickey) this can indicate a problem with your SSH key. Some things to check: Have you uploaded the key to SAFE? Please note that if the same key is reuploaded SAFE will not map the \"new\" key to Tursa. If for some reason this is required, please delete the key first, then reupload. Is ssh using the correct key? You can check which keys are being found and offered by ssh using ssh -vvv . If your private key has a non-default name you can use the -i flag to provide it to ssh, i.e. ssh -i path/to/key username@tursa.dirac.ed.ac.uk . Are you entering the passphrase correctly? You will be asked for your private key's passphrase first. If you enter it incorrectly you will usually be asked to enter it again, and usually up to three times in total, after which ssh will fail with Permission denied (publickey) . If you would like to confirm your passphrase without attempting to connect, you can use ssh-keygen -y -f /path/to/private/key . If successful, this command will print the corresponding public key. You can also use this to check it is the one uploaded to SAFE. Are permissions correct on the ssh key? One common issue is that the permissions are incorrect on the either the key file, or the directory it's contained in. On Linux/MacOS for example, if your private keys are held in ~/.ssh/ you can check this with ls -al ~/.ssh . This should give something similar to the following output: $ ls -al ~/.ssh/ drwx------. 2 user group 48 Jul 15 20:24 . drwx------. 12 user group 4096 Oct 13 12:11 .. -rw-------. 1 user group 113 Jul 15 20:23 authorized_keys -rw-------. 1 user group 12686 Jul 15 20:23 id_rsa -rw-r--r--. 1 user group 2785 Jul 15 20:23 id_rsa.pub -rw-r--r--. 1 user group 1967 Oct 13 14:11 known_hosts The important section here is the string of letters and dashes at the start, for the lines ending in . , id_rsa , and id_rsa.pub , which indicate permissions on the containing directory, private key, and public key respectively. If your permissions are not correct, they can be set with chmod . Consult the table below for the relevant chmod command. On Windows, permissions are handled differently but can be set by right-clicking on the file and selecting Properties > Security > Advanced. The user, SYSTEM, and Administrators should have Full control , and no other permissions should exist for both public and private key files, and the containing folder. Target Permissions chmod Code Directory drwx------ 700 Private Key -rw------- 600 Public Key -rw-r--r-- 644 chmod can be used to set permissions on the target in the following way: chmod <code> <target> . So for example to set correct permissions on the private key file id_rsa_Tursa one would use the command chmod 600 id_rsa_Tursa . Tip Unix file permissions can be understood in the following way. There are three groups that can have file permissions: (owning) users , (owning) groups , and others . The available permissions are read , write , and execute . The first character indicates whether the target is a file - , or directory d . The next three characters indicate the owning user's permissions. The first character is r if they have read permission, - if they don't, the second character is w if they have write permission, - if they don't, the third character is x if they have execute permission, - if they don't. This pattern is then repeated for group , and other permissions. For example the pattern -rw-r--r-- indicates that the owning user can read and write the file, members of the owning group can read it, and anyone else can also read it. The chmod codes are constructed by treating the user, group, and owner permission strings as binary numbers, then converting them to decimal. For example the permission string -rwx------ becomes 111 000 000 -> 700 .","title":"SSH key"},{"location":"tursa-user-guide/connecting/#ssh-verbose-output","text":"Verbose debugging output from ssh can be very useful for diagnosing the issue. In particular, it can be used to distinguish between problems with the SSH key and password - further details are given below. To enable verbose output add the -vvv flag to your SSH command. For example: ssh -vvv username@tursa.dirac.ed.ac.uk The output is lengthy, but somewhere in there you should see lines similar to the following: debug1: Next authentication method: keyboard-interactive debug2: userauth_kbdint debug3: send packet: type 50 debug2: we sent a keyboard-interactive packet, wait for reply debug3: receive packet: type 60 debug2: input_userauth_info_req debug2: input_userauth_info_req: num_prompts 1 Password: debug3: send packet: type 61 debug3: receive packet: type 60 debug2: input_userauth_info_req debug2: input_userauth_info_req: num_prompts 0 debug3: send packet: type 61 debug3: receive packet: type 51 Authenticated with partial success. debug1: Authentications that can continue: publickey,password If you do not see the Password: prompt you may have connection issues, or there could be a problem with the Tursa login nodes. If you do not see Authenticated with partial success it means your password was not accepted. You will be asked to re-enter your password, usually two more times before the connection will be rejected. Consider the suggestions under Password above. If you do see Authenticated with partial success , it means your password was accepted, and your SSH key will now be checked. You should next see something similiar to: debug1: Next authentication method: publickey debug1: Offering public key: RSA SHA256:<key_hash> <path_to_private_key> debug3: send_pubkey_test debug3: send packet: type 50 debug2: we sent a publickey packet, wait for reply debug3: receive packet: type 60 debug1: Server accepts key: pkalg rsa-sha2-512 blen 2071 debug2: input_userauth_pk_ok: fp SHA256:<key_hash> debug3: sign_and_send_pubkey: RSA SHA256:<key_hash> Enter passphrase for key '<path_to_private_key>': debug3: send packet: type 50 debug3: receive packet: type 52 debug1: Authentication succeeded (publickey). Most importantly, you can see which files ssh has checked for private keys, and you can see if any key is accepted. The line Authenticated succeeded indicates that the SSH key has been accepted. By default ssh will go through a list of standard private key files, as well as any you have specified with -i or a config file. This is fine, as long as one of the files mentioned is the one that matches the public key uploaded to SAFE. If your SSH key passphrase is incorrect, you will be asked to try again up to three times in total, before being disconnected with Permission denied (publickey) . If you enter your passphrase correctly, but still see this error message, please consider the advice under SSH key above.","title":"SSH verbose output"},{"location":"tursa-user-guide/data/","text":"Data management and transfer This section covers best practice and tools for data management on Tursa. Information If you have any questions on data management and transfer please do not hesitate to contact the DiRAC service desk at dirac-support@epcc.ed.ac.uk . Useful resources and links Harry Mangalam's guide on How to transfer large amounts of data via network . This provides lots of useful advice on transferring data. Data management We strongly recommend that you give some thought to how you use the various data storage facilities that are part of the Tursa service. This will not only allow you to use the machine more effectively but also to ensure that your valuable data is protected. Tursa storage The Tursa storage is provided by a parallel Lustre file system that provides your home directories and working storage. When you log in you will be placed in your home directory. The home directory for each user is located at: /home/[project code]/[group code]/[username] where [project code] is the code for your project (e.g., x01); [group code] is the code for your project group, if your project has groups, (e.g. x01-a) or the same as the project code, if not; [username] is your login name. Each project is allocated a portion of the total storage available, and the project PI will be able to sub-divide this quota among the groups and users within the project. As is standard practice on UNIX and Linux systems, the environment variable $HOME is automatically set to point to your home directory. Sharing data with other Tursa users How you share data with other Tursa users depends on whether or not they belong to the same project as you. Each project has two shared folders that can be used for sharing data. Sharing data with Tursa users in your project Each project has an inner shared folder. /home/[project code]/[project code]/shared This folder has read/write permissions for all project members. You can place any data you wish to share with other project members in this directory. For example, if your project code is x01 the inner shared folder would be located at /home/x01/x01/shared . Sharing data with all Tursa users Each project also has an outer shared folder.: /home/[project code]/shared It is writable by all project members and readable by any user on the system. You can place any data you wish to share with other Tursa users who are not members of your project in this directory. For example, if your project code is x01 the outer shared folder would be located at /home/x01/shared . Permissions You should check the permissions of any files that you place in the shared area, especially if those files were created in your own Tursa account Files of the latter type are likely to be readable by you only. The chmod command below shows how to make sure that a file placed in the outer shared folder is also readable by all Tursa users. chmod a+r /home/x01/shared/your-shared-file.txt Similarly, for the inner shared folder, chmod can be called such that read permission is granted to all users within the x01 project. chmod g+r /home/x01/x01/shared/your-shared-file.txt If you're sharing a set of files stored within a folder hierarchy the chmod is slightly more complicated. chmod -R a+Xr /home/x01/shared/my-shared-folder chmod -R g+Xr /home/x01/x01/shared/my-shared-folder The -R option ensures that the read permission is enabled recursively and the +X guarantees that the user(s) you're sharing the folder with can access the subdirectories below my-shared-folder . Archiving and data transfer Data transfer speed may be limited by many different factors so the best data transfer mechanism to use depends on the type of data being transferred and where the data is going. Disk speed - The Tursa file system is highly parallel, consisting of a very large number of high performance disk drives. This allows it to support a very high data bandwidth. Unless the remote system has a similar parallel file-system you may find your transfer speed limited by disk performance. Meta-data performance - Meta-data operations such as opening and closing files or listing the owner or size of a file are much less parallel than read/write operations. If your data consists of a very large number of small files you may find your transfer speed is limited by meta-data operations. Meta-data operations performed by other users of the system will interact strongly with those you perform so reducing the number of such operations you use, may reduce variability in your IO timings. Network speed - Data transfer performance can be limited by network speed. More importantly it is limited by the slowest section of the network between source and destination. Firewall speed - Most modern networks are protected by some form of firewall that filters out malicious traffic. This filtering has some overhead and can result in a reduction in data transfer performance. The needs of a general purpose network that hosts email/web-servers and desktop machines are quite different from a research network that needs to support high volume data transfers. If you are trying to transfer data to or from a host on a general purpose network you may find the firewall for that network will limit the transfer rate you can achieve. The method you use to transfer data to/from Tursa will depend on how much you want to transfer and where to. The methods we cover in this guide are: scp/sftp/rsync - These are the simplest methods of transferring data and can be used up to moderate amounts of data. If you are transferring data to your workstation/laptop then this is the method you will use. Before discussing specific data transfer methods, we cover archiving which is an essential process for transferring data efficiently. Archiving If you have related data that consists of a large number of small files it is strongly recommended to pack the files into a larger \"archive\" file for ease of transfer and manipulation. A single large file makes more efficient use of the file system and is easier to move and copy and transfer because significantly fewer meta-data operations are required. Archive files can be created using tools like tar and zip . tar The tar command packs files into a \"tape archive\" format. The command has general form: tar [options] [file(s)] Common options include: -c create a new archive -v verbosely list files processed -W verify the archive after writing -l confirm all file hard links are included in the archive -f use an archive file (for historical reasons, tar writes its output to stdout by default rather than a file). Putting these together: tar -cvWlf mydata.tar mydata will create and verify an archive. To extract files from a tar file, the option -x is used. For example: tar -xf mydata.tar will recover the contents of mydata.tar to the current working directory. To verify an existing tar file against a set of data, the -d (diff) option can be used. By default, no output will be given if a verification succeeds and an example of a failed verification follows: $> tar -df mydata.tar mydata/* mydata/damaged_file: Mod time differs mydata/damaged_file: Size differs Note tar files do not store checksums with their data, requiring the original data to be present during verification. Tip Further information on using tar can be found in the tar manual (accessed via man tar or at man tar ). zip The zip file format is widely used for archiving files and is supported by most major operating systems. The utility to create zip files can be run from the command line as: zip [options] mydata.zip [file(s)] Common options are: -r used to zip up a directory -# where \"#\" represents a digit ranging from 0 to 9 to specify compression level, 0 being the least and 9 the most. Default compression is -6 but we recommend using -0 to speed up the archiving process. Together: zip -0r mydata.zip mydata will create an archive. Note Unlike tar, zip files do not preserve hard links. File data will be copied on archive creation, e.g. an uncompressed zip archive of a 100MB file and a hard link to that file will be approximately 200MB in size. This makes zip an unsuitable format if you wish to precisely reproduce the file system layout. The corresponding unzip command is used to extract data from the archive. The simplest use case is: unzip mydata.zip which recovers the contents of the archive to the current working directory. Files in a zip archive are stored with a CRC checksum to help detect data loss. unzip provides options for verifying this checksum against the stored files. The relevant flag is -t and is used as follows: $> unzip -t mydata.zip Archive: mydata.zip testing: mydata/ OK testing: mydata/file OK No errors detected in compressed data of mydata.zip. Tip Further information on using zip can be found in the zip manual (accessed via man zip or at man zip ). Data transfer via SSH The easiest way of transferring data to/from Tursa is to use one of the standard programs based on the SSH protocol such as scp , sftp or rsync . These all use the same underlying mechanism (SSH) as you normally use to log-in to Tursa. So, once the the command has been executed via the command line, you will be prompted for your password for the specified account on the remote machine (Tursa in this case). To avoid having to type in your password multiple times you can set up a SSH key pair and use an SSH agent as documented in the User Guide at connecting . SSH data transfer performance considerations The SSH protocol encrypts all traffic it sends. This means that file transfer using SSH consumes a relatively large amount of CPU time at both ends of the transfer (for encryption and decryption). The Tursa login nodes have fairly fast processors that can sustain about 100 MB/s transfer. The encryption algorithm used is negotiated between the SSH client and the SSH server. There are command line flags that allow you to specify a preference for which encryption algorithm should be used. You may be able to improve transfer speeds by requesting a different algorithm than the default. The aes128-ctr or aes256-ctr algorithms are well supported and fast as they are implemented in hardware. These are not usually the default choice when using scp so you will need to manually specify them. A single SSH based transfer will usually not be able to saturate the available network bandwidth or the available disk bandwidth so you may see an overall improvement by running several data transfer operations in parallel. To reduce metadata interactions it is a good idea to overlap transfers of files from different directories. In addition, you should consider the following when transferring data: Only transfer those files that are required. Consider which data you really need to keep. Combine lots of small files into a single tar archive, to reduce the overheads associated in initiating many separate data transfers (over SSH, each file counts as an individual transfer). Compress data before transferring it, e.g. using gzip . scp The scp command creates a copy of a file, or if given the -r flag, a directory either from a local machine onto a remote machine or from a remote machine onto a local machine. For example, to transfer files to Tursa from a local machine: scp [options] source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.) In the above example, the [destination] is optional, as when left out scp will copy the source into your home directory. Also, the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. If you want to request a different encryption algorithm add the -c [algorithm-name] flag to the scp options. For example, to use the (usually faster) arcfour encryption algorithm you would use: scp [options] -c aes128-ctr source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.) rsync The rsync command can also transfer data between hosts using a ssh connection. It creates a copy of a file or, if given the -r flag, a directory at the given destination, similar to scp above. Given the -a option rsync can also make exact copies (including permissions), this is referred to as mirroring . In this case the rsync command is executed with ssh to create the copy on a remote machine. To transfer files to Tursa using rsync with ssh the command has the form: rsync [options] -e ssh source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.) In the above example, the [destination] is optional, as when left out rsync will copy the source into your home directory. Also the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. Additional flags can be specified for the underlying ssh command by using a quoted string as the argument of the -e flag. e.g. rsync [options] -e \"ssh -c arcfour\" source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.) Tip Further information on using rsync can be found in the rsync manual (accessed via man rsync or at man rsync ). SSH data transfer example: laptop/workstation to Tursa Here we have a short example demonstrating transfer of data directly from a laptop/workstation to Tursa. Note This guide assumes you are using a command line interface to transfer data. This means the terminal on Linux or macOS, MobaXterm local terminal on Windows or Powershell. Before we can transfer of data to Tursa we need to make sure we have an SSH key setup to access Tursa from the system we are transferring data from. If you are using the same system that you use to log into Tursa then you should be all set. If you want to use a different system you will need to generate a new SSH key there (or use SSH key forwarding) to allow you to connect to Tursa. Tip Remember that you will need to use both a key and your password to transfer data to Tursa. Once we know our keys are setup correctly, we are now ready to transfer data directly between the two machines. We begin by combining our important research data in to a single archive file using the following command: tar -czf all_my_files.tar.gz file1.txt file2.txt file3.txt We then initiate the data transfer from our system to Tursa, here using rsync to allow the transfer to be recommenced without needing to start again, in the event of a loss of connection or other failure. For example, using the SSH key in the file ~/.ssh/id_RSA_A2 on our local system: rsync -Pv -e\"ssh -c aes128-gcm@openssh.com -i $HOME/.ssh/id_RSA_A2\" ./all_my_files.tar.gz otbz19@tursa.dirac.ed.ac.uk:/home/z19/z19/otbz19/ Note the use of the -P flag to allow partial transfer -- the same command could be used to restart the transfer after a loss of connection. The -e flag allows specification of the ssh command - we have used this to add the location of the identity file. The -c option specifies the cipher to be used as aes128-gcm which has been found to increase performance. Unfortunately the ~ shortcut is not correctly expanded, so we have specified the full path. We move our research archive to our project work directory on Tursa. Note Remember to replace otbz19 with your username on Tursa. If we were unconcerned about being able to restart an interrupted transfer, we could instead use the scp command, scp -c aes128-gcm@openssh.com -i ~/.ssh/id_RSA_A2 all_my_files.tar.gz otbz19@transfer.dyn.tursa.ac.uk:/home/z19/z19/otbz19/ but rsync is recommended for larger transfers.","title":"Data Management and transfer"},{"location":"tursa-user-guide/data/#data-management-and-transfer","text":"This section covers best practice and tools for data management on Tursa. Information If you have any questions on data management and transfer please do not hesitate to contact the DiRAC service desk at dirac-support@epcc.ed.ac.uk .","title":"Data management and transfer"},{"location":"tursa-user-guide/data/#useful-resources-and-links","text":"Harry Mangalam's guide on How to transfer large amounts of data via network . This provides lots of useful advice on transferring data.","title":"Useful resources and links"},{"location":"tursa-user-guide/data/#data-management","text":"We strongly recommend that you give some thought to how you use the various data storage facilities that are part of the Tursa service. This will not only allow you to use the machine more effectively but also to ensure that your valuable data is protected.","title":"Data management"},{"location":"tursa-user-guide/data/#tursa-storage","text":"The Tursa storage is provided by a parallel Lustre file system that provides your home directories and working storage. When you log in you will be placed in your home directory. The home directory for each user is located at: /home/[project code]/[group code]/[username] where [project code] is the code for your project (e.g., x01); [group code] is the code for your project group, if your project has groups, (e.g. x01-a) or the same as the project code, if not; [username] is your login name. Each project is allocated a portion of the total storage available, and the project PI will be able to sub-divide this quota among the groups and users within the project. As is standard practice on UNIX and Linux systems, the environment variable $HOME is automatically set to point to your home directory.","title":"Tursa storage"},{"location":"tursa-user-guide/data/#sharing-data-with-other-tursa-users","text":"How you share data with other Tursa users depends on whether or not they belong to the same project as you. Each project has two shared folders that can be used for sharing data.","title":"Sharing data with other Tursa users"},{"location":"tursa-user-guide/data/#sharing-data-with-tursa-users-in-your-project","text":"Each project has an inner shared folder. /home/[project code]/[project code]/shared This folder has read/write permissions for all project members. You can place any data you wish to share with other project members in this directory. For example, if your project code is x01 the inner shared folder would be located at /home/x01/x01/shared .","title":"Sharing data with Tursa users in your project"},{"location":"tursa-user-guide/data/#sharing-data-with-all-tursa-users","text":"Each project also has an outer shared folder.: /home/[project code]/shared It is writable by all project members and readable by any user on the system. You can place any data you wish to share with other Tursa users who are not members of your project in this directory. For example, if your project code is x01 the outer shared folder would be located at /home/x01/shared .","title":"Sharing data with all Tursa users"},{"location":"tursa-user-guide/data/#permissions","text":"You should check the permissions of any files that you place in the shared area, especially if those files were created in your own Tursa account Files of the latter type are likely to be readable by you only. The chmod command below shows how to make sure that a file placed in the outer shared folder is also readable by all Tursa users. chmod a+r /home/x01/shared/your-shared-file.txt Similarly, for the inner shared folder, chmod can be called such that read permission is granted to all users within the x01 project. chmod g+r /home/x01/x01/shared/your-shared-file.txt If you're sharing a set of files stored within a folder hierarchy the chmod is slightly more complicated. chmod -R a+Xr /home/x01/shared/my-shared-folder chmod -R g+Xr /home/x01/x01/shared/my-shared-folder The -R option ensures that the read permission is enabled recursively and the +X guarantees that the user(s) you're sharing the folder with can access the subdirectories below my-shared-folder .","title":"Permissions"},{"location":"tursa-user-guide/data/#archiving-and-data-transfer","text":"Data transfer speed may be limited by many different factors so the best data transfer mechanism to use depends on the type of data being transferred and where the data is going. Disk speed - The Tursa file system is highly parallel, consisting of a very large number of high performance disk drives. This allows it to support a very high data bandwidth. Unless the remote system has a similar parallel file-system you may find your transfer speed limited by disk performance. Meta-data performance - Meta-data operations such as opening and closing files or listing the owner or size of a file are much less parallel than read/write operations. If your data consists of a very large number of small files you may find your transfer speed is limited by meta-data operations. Meta-data operations performed by other users of the system will interact strongly with those you perform so reducing the number of such operations you use, may reduce variability in your IO timings. Network speed - Data transfer performance can be limited by network speed. More importantly it is limited by the slowest section of the network between source and destination. Firewall speed - Most modern networks are protected by some form of firewall that filters out malicious traffic. This filtering has some overhead and can result in a reduction in data transfer performance. The needs of a general purpose network that hosts email/web-servers and desktop machines are quite different from a research network that needs to support high volume data transfers. If you are trying to transfer data to or from a host on a general purpose network you may find the firewall for that network will limit the transfer rate you can achieve. The method you use to transfer data to/from Tursa will depend on how much you want to transfer and where to. The methods we cover in this guide are: scp/sftp/rsync - These are the simplest methods of transferring data and can be used up to moderate amounts of data. If you are transferring data to your workstation/laptop then this is the method you will use. Before discussing specific data transfer methods, we cover archiving which is an essential process for transferring data efficiently.","title":"Archiving and data transfer"},{"location":"tursa-user-guide/data/#archiving","text":"If you have related data that consists of a large number of small files it is strongly recommended to pack the files into a larger \"archive\" file for ease of transfer and manipulation. A single large file makes more efficient use of the file system and is easier to move and copy and transfer because significantly fewer meta-data operations are required. Archive files can be created using tools like tar and zip .","title":"Archiving"},{"location":"tursa-user-guide/data/#tar","text":"The tar command packs files into a \"tape archive\" format. The command has general form: tar [options] [file(s)] Common options include: -c create a new archive -v verbosely list files processed -W verify the archive after writing -l confirm all file hard links are included in the archive -f use an archive file (for historical reasons, tar writes its output to stdout by default rather than a file). Putting these together: tar -cvWlf mydata.tar mydata will create and verify an archive. To extract files from a tar file, the option -x is used. For example: tar -xf mydata.tar will recover the contents of mydata.tar to the current working directory. To verify an existing tar file against a set of data, the -d (diff) option can be used. By default, no output will be given if a verification succeeds and an example of a failed verification follows: $> tar -df mydata.tar mydata/* mydata/damaged_file: Mod time differs mydata/damaged_file: Size differs Note tar files do not store checksums with their data, requiring the original data to be present during verification. Tip Further information on using tar can be found in the tar manual (accessed via man tar or at man tar ).","title":"tar"},{"location":"tursa-user-guide/data/#zip","text":"The zip file format is widely used for archiving files and is supported by most major operating systems. The utility to create zip files can be run from the command line as: zip [options] mydata.zip [file(s)] Common options are: -r used to zip up a directory -# where \"#\" represents a digit ranging from 0 to 9 to specify compression level, 0 being the least and 9 the most. Default compression is -6 but we recommend using -0 to speed up the archiving process. Together: zip -0r mydata.zip mydata will create an archive. Note Unlike tar, zip files do not preserve hard links. File data will be copied on archive creation, e.g. an uncompressed zip archive of a 100MB file and a hard link to that file will be approximately 200MB in size. This makes zip an unsuitable format if you wish to precisely reproduce the file system layout. The corresponding unzip command is used to extract data from the archive. The simplest use case is: unzip mydata.zip which recovers the contents of the archive to the current working directory. Files in a zip archive are stored with a CRC checksum to help detect data loss. unzip provides options for verifying this checksum against the stored files. The relevant flag is -t and is used as follows: $> unzip -t mydata.zip Archive: mydata.zip testing: mydata/ OK testing: mydata/file OK No errors detected in compressed data of mydata.zip. Tip Further information on using zip can be found in the zip manual (accessed via man zip or at man zip ).","title":"zip"},{"location":"tursa-user-guide/data/#data-transfer-via-ssh","text":"The easiest way of transferring data to/from Tursa is to use one of the standard programs based on the SSH protocol such as scp , sftp or rsync . These all use the same underlying mechanism (SSH) as you normally use to log-in to Tursa. So, once the the command has been executed via the command line, you will be prompted for your password for the specified account on the remote machine (Tursa in this case). To avoid having to type in your password multiple times you can set up a SSH key pair and use an SSH agent as documented in the User Guide at connecting .","title":"Data transfer via SSH"},{"location":"tursa-user-guide/data/#ssh-data-transfer-performance-considerations","text":"The SSH protocol encrypts all traffic it sends. This means that file transfer using SSH consumes a relatively large amount of CPU time at both ends of the transfer (for encryption and decryption). The Tursa login nodes have fairly fast processors that can sustain about 100 MB/s transfer. The encryption algorithm used is negotiated between the SSH client and the SSH server. There are command line flags that allow you to specify a preference for which encryption algorithm should be used. You may be able to improve transfer speeds by requesting a different algorithm than the default. The aes128-ctr or aes256-ctr algorithms are well supported and fast as they are implemented in hardware. These are not usually the default choice when using scp so you will need to manually specify them. A single SSH based transfer will usually not be able to saturate the available network bandwidth or the available disk bandwidth so you may see an overall improvement by running several data transfer operations in parallel. To reduce metadata interactions it is a good idea to overlap transfers of files from different directories. In addition, you should consider the following when transferring data: Only transfer those files that are required. Consider which data you really need to keep. Combine lots of small files into a single tar archive, to reduce the overheads associated in initiating many separate data transfers (over SSH, each file counts as an individual transfer). Compress data before transferring it, e.g. using gzip .","title":"SSH data transfer performance considerations"},{"location":"tursa-user-guide/data/#scp","text":"The scp command creates a copy of a file, or if given the -r flag, a directory either from a local machine onto a remote machine or from a remote machine onto a local machine. For example, to transfer files to Tursa from a local machine: scp [options] source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.) In the above example, the [destination] is optional, as when left out scp will copy the source into your home directory. Also, the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. If you want to request a different encryption algorithm add the -c [algorithm-name] flag to the scp options. For example, to use the (usually faster) arcfour encryption algorithm you would use: scp [options] -c aes128-ctr source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.)","title":"scp"},{"location":"tursa-user-guide/data/#rsync","text":"The rsync command can also transfer data between hosts using a ssh connection. It creates a copy of a file or, if given the -r flag, a directory at the given destination, similar to scp above. Given the -a option rsync can also make exact copies (including permissions), this is referred to as mirroring . In this case the rsync command is executed with ssh to create the copy on a remote machine. To transfer files to Tursa using rsync with ssh the command has the form: rsync [options] -e ssh source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.) In the above example, the [destination] is optional, as when left out rsync will copy the source into your home directory. Also the source should be the absolute path of the file/directory being copied or the command should be executed in the directory containing the source file/directory. Additional flags can be specified for the underlying ssh command by using a quoted string as the argument of the -e flag. e.g. rsync [options] -e \"ssh -c arcfour\" source user@tursa.dirac.ed.ac.uk:[destination] (Remember to replace user with your Tursa username in the example above.) Tip Further information on using rsync can be found in the rsync manual (accessed via man rsync or at man rsync ).","title":"rsync"},{"location":"tursa-user-guide/data/#ssh-data-transfer-example-laptopworkstation-to-tursa","text":"Here we have a short example demonstrating transfer of data directly from a laptop/workstation to Tursa. Note This guide assumes you are using a command line interface to transfer data. This means the terminal on Linux or macOS, MobaXterm local terminal on Windows or Powershell. Before we can transfer of data to Tursa we need to make sure we have an SSH key setup to access Tursa from the system we are transferring data from. If you are using the same system that you use to log into Tursa then you should be all set. If you want to use a different system you will need to generate a new SSH key there (or use SSH key forwarding) to allow you to connect to Tursa. Tip Remember that you will need to use both a key and your password to transfer data to Tursa. Once we know our keys are setup correctly, we are now ready to transfer data directly between the two machines. We begin by combining our important research data in to a single archive file using the following command: tar -czf all_my_files.tar.gz file1.txt file2.txt file3.txt We then initiate the data transfer from our system to Tursa, here using rsync to allow the transfer to be recommenced without needing to start again, in the event of a loss of connection or other failure. For example, using the SSH key in the file ~/.ssh/id_RSA_A2 on our local system: rsync -Pv -e\"ssh -c aes128-gcm@openssh.com -i $HOME/.ssh/id_RSA_A2\" ./all_my_files.tar.gz otbz19@tursa.dirac.ed.ac.uk:/home/z19/z19/otbz19/ Note the use of the -P flag to allow partial transfer -- the same command could be used to restart the transfer after a loss of connection. The -e flag allows specification of the ssh command - we have used this to add the location of the identity file. The -c option specifies the cipher to be used as aes128-gcm which has been found to increase performance. Unfortunately the ~ shortcut is not correctly expanded, so we have specified the full path. We move our research archive to our project work directory on Tursa. Note Remember to replace otbz19 with your username on Tursa. If we were unconcerned about being able to restart an interrupted transfer, we could instead use the scp command, scp -c aes128-gcm@openssh.com -i ~/.ssh/id_RSA_A2 all_my_files.tar.gz otbz19@transfer.dyn.tursa.ac.uk:/home/z19/z19/otbz19/ but rsync is recommended for larger transfers.","title":"SSH data transfer example: laptop/workstation to Tursa"},{"location":"tursa-user-guide/scheduler/","text":"Running jobs on Tursa As with most HPC services, Tursa uses a scheduler to manage access to resources and ensure that the thousands of different users of system are able to share the system and all get access to the resources they require. Tursa uses the Slurm software to schedule jobs. Writing a submission script is typically the most convenient way to submit your job to the scheduler. Example submission scripts (with explanations) for the most common job types are provided below. Interactive jobs are also available and can be particularly useful for developing and debugging applications. More details are available below. Hint If you have any questions on how to run jobs on Tursa do not hesitate to contact the DiRAC Service Desk . You typically interact with Slurm by issuing Slurm commands from the login nodes (to submit, check and cancel jobs), and by specifying Slurm directives that describe the resources required for your jobs in job submission scripts. Resources GPUh Time used on Tursa nodes is measured in GPUh. 1 GPUh = 1 GPU for 1 hour. So a Tursa compute node with 4 GPUs would cost 4 GPUh per hour. Note The minimum resource request on Tursa is one full node which is charged at a rate of 4 GPUh per hour. Checking available budget You can check in SAFE by selecting Login accounts from the menu, select the login account you want to query. Under Login account details you will see each of the budget codes you have access to listed e.g. e123 resources and then under Resource Pool to the right of this, a note of the remaining budgets. When logged in to the machine you can also use the command sacctmgr show assoc where user=$LOGNAME format=account,user,maxtresmins This will list all the budget codes that you have access to e.g. Account User MaxTRESMins ---------- ---------- ------------- e123 userx cpu=0 e123-test userx This shows that userx is a member of budgets e123 and e123-test . However, the cpu=0 indicates that the e123 budget is empty or disabled. This user can submit jobs using the e123-test budget. To see the number of coreh or GPUh remaining you must check in SAFE . Charging Jobs run on Tursa are charged for the time they use i.e. from the time the job begins to run until the time the job ends (not the full wall time requested). Jobs are charged for the full number of nodes which are requested, even if they are not all used. Charging takes place at the time the job ends, and the job is charged in full to the budget which is live at the end time. Basic Slurm commands There are three key commands used to interact with the Slurm on the command line: sinfo - Get information on the partitions and resources available sbatch jobscript.slurm - Submit a job submission script (in this case called: jobscript.slurm ) to the scheduler squeue - Get the current status of jobs submitted to the scheduler scancel 12345 - Cancel a job (in this case with the job ID 12345 ) We cover each of these commands in more detail below. sinfo : information on resources sinfo is used to query information about available resources and partitions. Without any options, sinfo lists the status of all resources and partitions, e.g. [dc-user1@tursa-login1 ~]$ sinfo PARTITION AVAIL TIMELIMIT NODES STATE NODELIST cpu up infinite 6 idle tu-c0r0n[66-71] gpu* up infinite 2 drain* tu-c0r0n[27,30] gpu* up infinite 1 down* tu-c0r4n33 gpu* up infinite 1 drain tu-c0r3n81 gpu* up infinite 58 alloc tu-c0r0n[00,03,06,09,12,15,18,21,24,33,36,39,42,45],tu-c0r1n[24,27,30,33,60,63,66,69,72,75,78,81,84,87,90,93],tu-c0r2n[24,27,30,33,60,63,66,69],tu-c0r3n[03,72,75,78,84,87,90,93],tu-c0r4n[00,03,06,12,15,24,27,30,60,63,66,69] gpu* up infinite 50 idle tu-c0r1n[00,03,06,09,12,15,18,21],tu-c0r2n[00,03,06,09,12,15,18,21,72,75,78,81,84,87,90,93],tu-c0r3n[00,06,09,12,15,18,21,24,27,30,33,60,63,66,69],tu-c0r4n[09,18,21,72,75,78,81,84,87,90,93] rack0 up infinite 2 drain* tu-c0r0n[27,30] rack0 up infinite 14 alloc tu-c0r0n[00,03,06,09,12,15,18,21,24,33,36,39,42,45] rack1 up infinite 16 alloc tu-c0r1n[24,27,30,33,60,63,66,69,72,75,78,81,84,87,90,93] rack1 up infinite 8 idle tu-c0r1n[00,03,06,09,12,15,18,21] rack2 up infinite 8 alloc tu-c0r2n[24,27,30,33,60,63,66,69] rack2 up infinite 16 idle tu-c0r2n[00,03,06,09,12,15,18,21,72,75,78,81,84,87,90,93] rack3 up infinite 1 drain tu-c0r3n81 rack3 up infinite 8 alloc tu-c0r3n[03,72,75,78,84,87,90,93] rack3 up infinite 15 idle tu-c0r3n[00,06,09,12,15,18,21,24,27,30,33,60,63,66,69] rack4 up infinite 1 down* tu-c0r4n33 rack4 up infinite 12 alloc tu-c0r4n[00,03,06,12,15,24,27,30,60,63,66,69] rack4 up infinite 11 idle tu-c0r4n[09,18,21,72,75,78,81,84,87,90,93] alloc nodes are those that are running jobs idle nodes are empty drain , down , maint nodes are unavailable to users sbatch : submitting jobs sbatch is used to submit a job script to the job submission system. The script will typically contain one or more srun commands to launch parallel tasks. When you submit the job, the scheduler provides the job ID, which is used to identify this job in other Slurm commands and when looking at resource usage in SAFE. sbatch test-job.slurm Submitted batch job 12345 squeue : monitoring jobs squeue without any options or arguments shows the current status of all jobs known to the scheduler. For example: squeue will list all jobs on Tursa. The output of this is often large. You can restrict the output to just your jobs by adding the -u $USER option: squeue -u $USER scancel : deleting jobs scancel is used to delete a jobs from the scheduler. If the job is waiting to run it is simply cancelled, if it is a running job then it is stopped immediately. You need to provide the job ID of the job you wish to cancel/stop. For example: scancel 12345 will cancel (if waiting) or stop (if running) the job with ID 12345 . Resource Limits The Tursa resource limits for any given job are covered by three separate attributes. The amount of primary resource you require, i.e., number of compute nodes. The partition that you want to use - this specifies the nodes that are eligible to run your job. The Quality of Service (QoS) that you want to use - this specifies the job limits that apply. Primary resource The primary resource you can request for your job is the compute node. Information The --exclusive option is enforced on Tursa which means you will always have access to all of the memory on the compute node regardless of how many processes are actually running on the node. Note You will not generally have access to the full amount of memory resource on the the node as some is retained for running the operating system and other system processes. Partitions On Tursa, compute nodes are grouped into partitions. You will have to specify a partition using the --partition option in your Slurm submission script. The following table has a list of active partitions on Tursa. Partition Description Max nodes available cpu CPU nodes with AMD EPYC 32-core processor \u00d7 2 6 gpu GPU nodes with AMD EPYC 32-core processor and NVIDIA A100 GPU \u00d7 4 114 You can list the active partitions by running sinfo . Tip You may not have access to all the available partitions. Quality of Service (QoS) On Tursa, job limits are defined by the requested Quality of Service (QoS), as specified by the --qos Slurm directive. The following table lists the active QoS on Tursa. QoS Max Nodes Per Job Max Walltime Jobs Queued Jobs Running Partition(s) Notes standard 64 48 hrs 16 16 gpu, cpu Only jobs sizes that are powers of 2 nodes are allowed (i.e. 1, 2, 4, 8, 16, 32, 64 nodes) You can find out the QoS that you can use by running the following command: sacctmgr show assoc user=$USER cluster=tursa format=cluster,account,user,qos%50 Hint If you have needs which do not fit within the current QoS, please contact the Service Desk and we can discuss how to accommodate your requirements. Important Only jobs sizes that are powers of 2 nodes are allowed. i.e. 1, 2, 4, 8, 16, 32, 64 nodes on the gpu partition and 1, 2, 4 nodes on the cpu partition. Priority Job priority on Tursa depends on a number of different factors: The QoS your job has specified The amount of time you have been queuing for Your current fairshare factor Each of these factors is normalised to a value between 0 and 1, is multiplied with a weight and the resulting values combined to produce a priority for the job. The current job priority formula on Tursa is: Priority = [10000 * P(QoS)] + [500 * P(Age)] + [300 * P(Fairshare)] The priority factors are: P(QoS) - The QoS priority normalised to a value between 0 and 1. The maximum raw value is 10000 and the minimum is 0. standard QoS has a value of 5000 and low QoS a value of 1. P(Age) - The priority based on the job age normalised to a value between 0 and 1. The maximum raw value is 14 days (where P(Age) = 1). P(Fairshare) - The fairshare priority normalised to a value between 0 and 1. Your fairshare priority is determined by a combination of your budget code fairshare value and your user fairshare value within that budget code. The more use that the budget code you are using has made of the system recently relative to other budget codes on the system, the lower the budget code fairshare value will be; and the more use you have made of the system recently relative to other users within your budget code, the lower your user fairshare value will be. The decay half life for fairshare on Tursa is set to 14 days. More information on the Slurm fairshare algorithm . You can view the priorities for current queued jobs on the system with the sprio command: [dc-user1@tursa-login1 ~]$ sprio JOBID PARTITION PRIORITY SITE AGE FAIRSHARE QOS 43963 gpu 5055 0 51 5 5000 43975 gpu 5061 0 41 20 5000 43976 gpu 5061 0 41 20 5000 43982 gpu 5046 0 26 20 5000 43986 gpu 5011 0 6 5 5000 43996 gpu 5020 0 0 20 5000 43997 gpu 5020 0 0 20 5000 Troubleshooting Slurm error messages An incorrect submission will cause Slurm to return an error. Some common problems are listed below, with a suggestion about the likely cause: sbatch: unrecognized option <text> One of your options is invalid or has a typo. man sbatch to help. error: Batch job submission failed: No partition specified or system default partition A --partition= option is missing. You must specify the partition (see the list above). This is most often --partition=standard . error: invalid partition specified: <partition> error: Batch job submission failed: Invalid partition name specified Check the partition exists and check the spelling is correct. error: Batch job submission failed: Invalid account or account/partition combination specified This probably means an invalid account has been given. Check the --account= options against valid accounts in SAFE. error: Batch job submission failed: Invalid qos specification A QoS option is either missing or invalid. Check the script has a --qos= option and that the option is a valid one from the table above. (Check the spelling of the QoS is correct.) error: Your job has no time specification (--time=)... Add an option of the form --time=hours:minutes:seconds to the submission script. E.g., --time=01:30:00 gives a time limit of 90 minutes. error: QOSMaxWallDurationPerJobLimit error: Batch job submission failed: Job violates accounting/QOS policy (job submit limit, user's size and/or time limits) The script has probably specified a time limit which is too long for the corresponding QoS. E.g., the time limit for the short QoS is 20 minutes. Slurm queued reasons The squeue command allows users to view information for jobs managed by Slurm. Jobs typically go through the following states: PENDING, RUNNING, COMPLETING, and COMPLETED. The first table provides a description of some job state codes. The second table provides a description of the reasons that cause a job to be in a state. Status Code Description PENDING PD Job is awaiting resource allocation. RUNNING R Job currently has an allocation. SUSPENDED S Job currently has an allocation. COMPLETING CG Job is in the process of completing. Some processes on some nodes may still be active. COMPLETED CD Job has terminated all processes on all nodes with an exit code of zero. TIMEOUT TO Job terminated upon reaching its time limit. STOPPED ST Job has an allocation, but execution has been stopped with SIGSTOP signal. CPUS have been retained by this job. OUT_OF_MEMORY OOM Job experienced out of memory error. FAILED F Job terminated with non-zero exit code or other failure condition. NODE_FAIL NF Job terminated due to failure of one or more allocated nodes. CANCELLED CA Job was explicitly cancelled by the user or system administrator. The job may or may not have been initiated. For a full list of see Job State Codes . Reason Description Priority One or more higher priority jobs exist for this partition or advanced reservation. Resources The job is waiting for resources to become available. BadConstraints The job's constraints can not be satisfied. BeginTime The job's earliest start time has not yet been reached. Dependency This job is waiting for a dependent job to complete. Licenses The job is waiting for a license. WaitingForScheduling No reason has been set for this job yet. Waiting for the scheduler to determine the appropriate reason. Prolog Its PrologSlurmctld program is still running. JobHeldAdmin The job is held by a system administrator. JobHeldUser The job is held by the user. JobLaunchFailure The job could not be launched. This may be due to a file system problem, invalid program name, etc. NonZeroExitCode The job terminated with a non-zero exit code. InvalidAccount The job's account is invalid. InvalidQOS The job's QOS is invalid. QOSUsageThreshold Required QOS threshold has been breached. QOSJobLimit The job's QOS has reached its maximum job count. QOSResourceLimit The job's QOS has reached some resource limit. QOSTimeLimit The job's QOS has reached its time limit. NodeDown A node required by the job is down. TimeLimit The job exhausted its time limit. ReqNodeNotAvail Some node specifically required by the job is not currently available. The node may currently be in use, reserved for another job, in an advanced reservation, DOWN, DRAINED, or not responding. Nodes which are DOWN, DRAINED, or not responding will be identified as part of the job's \"reason\" field as \"UnavailableNodes\". Such nodes will typically require the intervention of a system administrator to make available. For a full list of see Job Reasons . Output from Slurm jobs Slurm places standard output (STDOUT) and standard error (STDERR) for each job in the file slurm_<JobID>.out . This file appears in the job's working directory once your job starts running. Hint Output may be buffered - to enable live output, e.g. for monitoring job status, add --unbuffered to the srun command in your SLURM script. Specifying resources in job scripts You specify the resources you require for your job using directives at the top of your job submission script using lines that start with the directive #SBATCH . Hint Most options provided using #SBATCH directives can also be specified as command line options to srun . If you do not specify any options, then the default for each option will be applied. As a minimum, all job submissions must specify the budget that they wish to charge the job too with the option: --account=<budgetID> your budget ID is usually something like t01 or t01-test . You can see which budget codes you can charge to in SAFE. Other common options that are used are: --time=<hh:mm:ss> the maximum walltime for your job. e.g. For a 6.5 hour walltime, you would use --time=6:30:0 . --job-name=<jobname> set a name for the job to help identify it in In addition, parallel jobs will also need to specify how many nodes, parallel processes and threads they require. --nodes=<nodes> the number of nodes to use for the job. --tasks-per-node=<processes per node> the number of parallel processes (e.g. MPI ranks) per node. For Grid this will typically be 4 to give 1 MPI process per GPU --cpus-per-task=8 for Grid jobs where you typically use 1 MPI process per GPU, 4 per node, this will usually be 8 (so that the 32 cores on a node are evenly divided between the 4 MPI processes) --gres=gpu:4 the number of GPU to use per node. This will almost always be 4 to use all GPUs on a node Note For parallel jobs, Tursa operates in a node exclusive way. This means that you are assigned resources in the units of full compute nodes for your jobs ( i.e. 32 cores and 4 GPU) and that no other user can share those compute nodes with you. Hence, the minimum amount of resource you can request for a parallel job is 1 node (or 32 cores and 4 GPU). To prevent the behaviour of batch scripts being dependent on the user environment at the point of submission, the option --export=none prevents the user environment from being exported to the batch system. Using the --export=none means that the behaviour of batch submissions should be repeatable. We strongly recommend its use, although see the following section to enable access to the usual modules. mpirun : Launching parallel jobs If you are running parallel jobs, your job submission script should contain one or more mpirun commands to launch the parallel executable across the compute nodes. You will usually add the following options to mpirun : -np <number of MPI processes> : specify the number of MPI processes to launch --map-by-numa -x $LD_LIBRARY_PATH : ensure that the library paths are available to MPI processes --bind-to none Example job submission scripts Example: job submission script for Grid parallel job using CUDA A job submission script for a Grid job that uses 4 compute nodes, 16 MPI processes per node and 4 GPUs per node: #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_Grid_job #SBATCH --time=12:0:0 #SBATCH --nodes=4 #SBATCH --tasks-per-node=4 #SBATCH --cpus-per-task=8 #SBATCH --gres=gpu:4 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Load the correct modules module load gcc/9.3.0 module load cuda/11.4.1 module load openmpi/4.1.1-cuda11.4 ACC_THREADS=8 export OMP_NUM_THREADS=8 # Settings for MPI performance export OMPI_MCA_btl=^uct,openib export UCX_TLS=rc,rc_x,sm,cuda_copy,cuda_ipc,gdr_copy export UCX_RNDV_THRESH=16384 export UCX_RNDV_SCHEME=put_zcopy export UCX_IB_GPU_DIRECT_RDMA=yes export UCX_MEMTYPE_CACHE=n export OMPI_MCA_io=romio321 export OMPI_MCA_btl_openib_allow_ib=true export OMPI_MCA_btl_openib_device_type=infiniband export OMPI_MCA_btl_openib_if_exclude=mlx5_1,mlx5_2,mlx5_3 # These will need to be changed to match the actual application you are running application=\"my_mpi_openmp_app.x\" options=\"arg 1 arg2\" mpirun -np $SLURM_NTASKS --map-by numa -x LD_LIBRARY_PATH --bind-to none ./wrapper.sh ${application} ${options}\" This will run your executable \"grid\" in parallel usimg 16 MPI processes on 4 nodes, 8 OpenMP thread will be used per MPI process and 4 GPUs will be used per node (32 cores per node, 4 GPUs per node). Slurm will allocate 4 nodes to your job and srun will place 4 MPI processes on each node. When running on Tursa it is important that we specify how each of the GPU's interacts with the network interfaces to reach optimal network communication performance. To achieve this, we introduce a wrapper script (specified as wrapper.sh in the example job script above) that sets a number of environment parameters for each rank in a node (each GPU in a node) explicitly tell each rank which network interface it should use to communicate internode. wrapper.sh script example: #!/bin/bash lrank=$OMPI_COMM_WORLD_LOCAL_RANK numa1=$(( 2 * $lrank)) numa2=$(( 2 * $lrank + 1 )) netdev=mlx5_${lrank}:1 export CUDA_VISIBLE_DEVICES=$OMPI_COMM_WORLD_LOCAL_RANK export UCX_NET_DEVICES=mlx5_${lrank}:1 BINDING=\"--interleave=$numa1,$numa2\" echo \"`hostname` - $lrank device=$CUDA_VISIBLE_DEVICES binding=$BINDING\" numactl ${BINDING} $* See above for a more detailed discussion of the different sbatch options","title":"Running jobs on Tursa"},{"location":"tursa-user-guide/scheduler/#running-jobs-on-tursa","text":"As with most HPC services, Tursa uses a scheduler to manage access to resources and ensure that the thousands of different users of system are able to share the system and all get access to the resources they require. Tursa uses the Slurm software to schedule jobs. Writing a submission script is typically the most convenient way to submit your job to the scheduler. Example submission scripts (with explanations) for the most common job types are provided below. Interactive jobs are also available and can be particularly useful for developing and debugging applications. More details are available below. Hint If you have any questions on how to run jobs on Tursa do not hesitate to contact the DiRAC Service Desk . You typically interact with Slurm by issuing Slurm commands from the login nodes (to submit, check and cancel jobs), and by specifying Slurm directives that describe the resources required for your jobs in job submission scripts.","title":"Running jobs on Tursa"},{"location":"tursa-user-guide/scheduler/#resources","text":"","title":"Resources"},{"location":"tursa-user-guide/scheduler/#gpuh","text":"Time used on Tursa nodes is measured in GPUh. 1 GPUh = 1 GPU for 1 hour. So a Tursa compute node with 4 GPUs would cost 4 GPUh per hour. Note The minimum resource request on Tursa is one full node which is charged at a rate of 4 GPUh per hour.","title":"GPUh"},{"location":"tursa-user-guide/scheduler/#checking-available-budget","text":"You can check in SAFE by selecting Login accounts from the menu, select the login account you want to query. Under Login account details you will see each of the budget codes you have access to listed e.g. e123 resources and then under Resource Pool to the right of this, a note of the remaining budgets. When logged in to the machine you can also use the command sacctmgr show assoc where user=$LOGNAME format=account,user,maxtresmins This will list all the budget codes that you have access to e.g. Account User MaxTRESMins ---------- ---------- ------------- e123 userx cpu=0 e123-test userx This shows that userx is a member of budgets e123 and e123-test . However, the cpu=0 indicates that the e123 budget is empty or disabled. This user can submit jobs using the e123-test budget. To see the number of coreh or GPUh remaining you must check in SAFE .","title":"Checking available budget"},{"location":"tursa-user-guide/scheduler/#charging","text":"Jobs run on Tursa are charged for the time they use i.e. from the time the job begins to run until the time the job ends (not the full wall time requested). Jobs are charged for the full number of nodes which are requested, even if they are not all used. Charging takes place at the time the job ends, and the job is charged in full to the budget which is live at the end time.","title":"Charging"},{"location":"tursa-user-guide/scheduler/#basic-slurm-commands","text":"There are three key commands used to interact with the Slurm on the command line: sinfo - Get information on the partitions and resources available sbatch jobscript.slurm - Submit a job submission script (in this case called: jobscript.slurm ) to the scheduler squeue - Get the current status of jobs submitted to the scheduler scancel 12345 - Cancel a job (in this case with the job ID 12345 ) We cover each of these commands in more detail below.","title":"Basic Slurm commands"},{"location":"tursa-user-guide/scheduler/#sinfo-information-on-resources","text":"sinfo is used to query information about available resources and partitions. Without any options, sinfo lists the status of all resources and partitions, e.g. [dc-user1@tursa-login1 ~]$ sinfo PARTITION AVAIL TIMELIMIT NODES STATE NODELIST cpu up infinite 6 idle tu-c0r0n[66-71] gpu* up infinite 2 drain* tu-c0r0n[27,30] gpu* up infinite 1 down* tu-c0r4n33 gpu* up infinite 1 drain tu-c0r3n81 gpu* up infinite 58 alloc tu-c0r0n[00,03,06,09,12,15,18,21,24,33,36,39,42,45],tu-c0r1n[24,27,30,33,60,63,66,69,72,75,78,81,84,87,90,93],tu-c0r2n[24,27,30,33,60,63,66,69],tu-c0r3n[03,72,75,78,84,87,90,93],tu-c0r4n[00,03,06,12,15,24,27,30,60,63,66,69] gpu* up infinite 50 idle tu-c0r1n[00,03,06,09,12,15,18,21],tu-c0r2n[00,03,06,09,12,15,18,21,72,75,78,81,84,87,90,93],tu-c0r3n[00,06,09,12,15,18,21,24,27,30,33,60,63,66,69],tu-c0r4n[09,18,21,72,75,78,81,84,87,90,93] rack0 up infinite 2 drain* tu-c0r0n[27,30] rack0 up infinite 14 alloc tu-c0r0n[00,03,06,09,12,15,18,21,24,33,36,39,42,45] rack1 up infinite 16 alloc tu-c0r1n[24,27,30,33,60,63,66,69,72,75,78,81,84,87,90,93] rack1 up infinite 8 idle tu-c0r1n[00,03,06,09,12,15,18,21] rack2 up infinite 8 alloc tu-c0r2n[24,27,30,33,60,63,66,69] rack2 up infinite 16 idle tu-c0r2n[00,03,06,09,12,15,18,21,72,75,78,81,84,87,90,93] rack3 up infinite 1 drain tu-c0r3n81 rack3 up infinite 8 alloc tu-c0r3n[03,72,75,78,84,87,90,93] rack3 up infinite 15 idle tu-c0r3n[00,06,09,12,15,18,21,24,27,30,33,60,63,66,69] rack4 up infinite 1 down* tu-c0r4n33 rack4 up infinite 12 alloc tu-c0r4n[00,03,06,12,15,24,27,30,60,63,66,69] rack4 up infinite 11 idle tu-c0r4n[09,18,21,72,75,78,81,84,87,90,93] alloc nodes are those that are running jobs idle nodes are empty drain , down , maint nodes are unavailable to users","title":"sinfo: information on resources"},{"location":"tursa-user-guide/scheduler/#sbatch-submitting-jobs","text":"sbatch is used to submit a job script to the job submission system. The script will typically contain one or more srun commands to launch parallel tasks. When you submit the job, the scheduler provides the job ID, which is used to identify this job in other Slurm commands and when looking at resource usage in SAFE. sbatch test-job.slurm Submitted batch job 12345","title":"sbatch: submitting jobs"},{"location":"tursa-user-guide/scheduler/#squeue-monitoring-jobs","text":"squeue without any options or arguments shows the current status of all jobs known to the scheduler. For example: squeue will list all jobs on Tursa. The output of this is often large. You can restrict the output to just your jobs by adding the -u $USER option: squeue -u $USER","title":"squeue: monitoring jobs"},{"location":"tursa-user-guide/scheduler/#scancel-deleting-jobs","text":"scancel is used to delete a jobs from the scheduler. If the job is waiting to run it is simply cancelled, if it is a running job then it is stopped immediately. You need to provide the job ID of the job you wish to cancel/stop. For example: scancel 12345 will cancel (if waiting) or stop (if running) the job with ID 12345 .","title":"scancel: deleting jobs"},{"location":"tursa-user-guide/scheduler/#resource-limits","text":"The Tursa resource limits for any given job are covered by three separate attributes. The amount of primary resource you require, i.e., number of compute nodes. The partition that you want to use - this specifies the nodes that are eligible to run your job. The Quality of Service (QoS) that you want to use - this specifies the job limits that apply.","title":"Resource Limits"},{"location":"tursa-user-guide/scheduler/#primary-resource","text":"The primary resource you can request for your job is the compute node. Information The --exclusive option is enforced on Tursa which means you will always have access to all of the memory on the compute node regardless of how many processes are actually running on the node. Note You will not generally have access to the full amount of memory resource on the the node as some is retained for running the operating system and other system processes.","title":"Primary resource"},{"location":"tursa-user-guide/scheduler/#partitions","text":"On Tursa, compute nodes are grouped into partitions. You will have to specify a partition using the --partition option in your Slurm submission script. The following table has a list of active partitions on Tursa. Partition Description Max nodes available cpu CPU nodes with AMD EPYC 32-core processor \u00d7 2 6 gpu GPU nodes with AMD EPYC 32-core processor and NVIDIA A100 GPU \u00d7 4 114 You can list the active partitions by running sinfo . Tip You may not have access to all the available partitions.","title":"Partitions"},{"location":"tursa-user-guide/scheduler/#quality-of-service-qos","text":"On Tursa, job limits are defined by the requested Quality of Service (QoS), as specified by the --qos Slurm directive. The following table lists the active QoS on Tursa. QoS Max Nodes Per Job Max Walltime Jobs Queued Jobs Running Partition(s) Notes standard 64 48 hrs 16 16 gpu, cpu Only jobs sizes that are powers of 2 nodes are allowed (i.e. 1, 2, 4, 8, 16, 32, 64 nodes) You can find out the QoS that you can use by running the following command: sacctmgr show assoc user=$USER cluster=tursa format=cluster,account,user,qos%50 Hint If you have needs which do not fit within the current QoS, please contact the Service Desk and we can discuss how to accommodate your requirements. Important Only jobs sizes that are powers of 2 nodes are allowed. i.e. 1, 2, 4, 8, 16, 32, 64 nodes on the gpu partition and 1, 2, 4 nodes on the cpu partition.","title":"Quality of Service (QoS)"},{"location":"tursa-user-guide/scheduler/#priority","text":"Job priority on Tursa depends on a number of different factors: The QoS your job has specified The amount of time you have been queuing for Your current fairshare factor Each of these factors is normalised to a value between 0 and 1, is multiplied with a weight and the resulting values combined to produce a priority for the job. The current job priority formula on Tursa is: Priority = [10000 * P(QoS)] + [500 * P(Age)] + [300 * P(Fairshare)] The priority factors are: P(QoS) - The QoS priority normalised to a value between 0 and 1. The maximum raw value is 10000 and the minimum is 0. standard QoS has a value of 5000 and low QoS a value of 1. P(Age) - The priority based on the job age normalised to a value between 0 and 1. The maximum raw value is 14 days (where P(Age) = 1). P(Fairshare) - The fairshare priority normalised to a value between 0 and 1. Your fairshare priority is determined by a combination of your budget code fairshare value and your user fairshare value within that budget code. The more use that the budget code you are using has made of the system recently relative to other budget codes on the system, the lower the budget code fairshare value will be; and the more use you have made of the system recently relative to other users within your budget code, the lower your user fairshare value will be. The decay half life for fairshare on Tursa is set to 14 days. More information on the Slurm fairshare algorithm . You can view the priorities for current queued jobs on the system with the sprio command: [dc-user1@tursa-login1 ~]$ sprio JOBID PARTITION PRIORITY SITE AGE FAIRSHARE QOS 43963 gpu 5055 0 51 5 5000 43975 gpu 5061 0 41 20 5000 43976 gpu 5061 0 41 20 5000 43982 gpu 5046 0 26 20 5000 43986 gpu 5011 0 6 5 5000 43996 gpu 5020 0 0 20 5000 43997 gpu 5020 0 0 20 5000","title":"Priority"},{"location":"tursa-user-guide/scheduler/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"tursa-user-guide/scheduler/#slurm-error-messages","text":"An incorrect submission will cause Slurm to return an error. Some common problems are listed below, with a suggestion about the likely cause: sbatch: unrecognized option <text> One of your options is invalid or has a typo. man sbatch to help. error: Batch job submission failed: No partition specified or system default partition A --partition= option is missing. You must specify the partition (see the list above). This is most often --partition=standard . error: invalid partition specified: <partition> error: Batch job submission failed: Invalid partition name specified Check the partition exists and check the spelling is correct. error: Batch job submission failed: Invalid account or account/partition combination specified This probably means an invalid account has been given. Check the --account= options against valid accounts in SAFE. error: Batch job submission failed: Invalid qos specification A QoS option is either missing or invalid. Check the script has a --qos= option and that the option is a valid one from the table above. (Check the spelling of the QoS is correct.) error: Your job has no time specification (--time=)... Add an option of the form --time=hours:minutes:seconds to the submission script. E.g., --time=01:30:00 gives a time limit of 90 minutes. error: QOSMaxWallDurationPerJobLimit error: Batch job submission failed: Job violates accounting/QOS policy (job submit limit, user's size and/or time limits) The script has probably specified a time limit which is too long for the corresponding QoS. E.g., the time limit for the short QoS is 20 minutes.","title":"Slurm error messages"},{"location":"tursa-user-guide/scheduler/#slurm-queued-reasons","text":"The squeue command allows users to view information for jobs managed by Slurm. Jobs typically go through the following states: PENDING, RUNNING, COMPLETING, and COMPLETED. The first table provides a description of some job state codes. The second table provides a description of the reasons that cause a job to be in a state. Status Code Description PENDING PD Job is awaiting resource allocation. RUNNING R Job currently has an allocation. SUSPENDED S Job currently has an allocation. COMPLETING CG Job is in the process of completing. Some processes on some nodes may still be active. COMPLETED CD Job has terminated all processes on all nodes with an exit code of zero. TIMEOUT TO Job terminated upon reaching its time limit. STOPPED ST Job has an allocation, but execution has been stopped with SIGSTOP signal. CPUS have been retained by this job. OUT_OF_MEMORY OOM Job experienced out of memory error. FAILED F Job terminated with non-zero exit code or other failure condition. NODE_FAIL NF Job terminated due to failure of one or more allocated nodes. CANCELLED CA Job was explicitly cancelled by the user or system administrator. The job may or may not have been initiated. For a full list of see Job State Codes . Reason Description Priority One or more higher priority jobs exist for this partition or advanced reservation. Resources The job is waiting for resources to become available. BadConstraints The job's constraints can not be satisfied. BeginTime The job's earliest start time has not yet been reached. Dependency This job is waiting for a dependent job to complete. Licenses The job is waiting for a license. WaitingForScheduling No reason has been set for this job yet. Waiting for the scheduler to determine the appropriate reason. Prolog Its PrologSlurmctld program is still running. JobHeldAdmin The job is held by a system administrator. JobHeldUser The job is held by the user. JobLaunchFailure The job could not be launched. This may be due to a file system problem, invalid program name, etc. NonZeroExitCode The job terminated with a non-zero exit code. InvalidAccount The job's account is invalid. InvalidQOS The job's QOS is invalid. QOSUsageThreshold Required QOS threshold has been breached. QOSJobLimit The job's QOS has reached its maximum job count. QOSResourceLimit The job's QOS has reached some resource limit. QOSTimeLimit The job's QOS has reached its time limit. NodeDown A node required by the job is down. TimeLimit The job exhausted its time limit. ReqNodeNotAvail Some node specifically required by the job is not currently available. The node may currently be in use, reserved for another job, in an advanced reservation, DOWN, DRAINED, or not responding. Nodes which are DOWN, DRAINED, or not responding will be identified as part of the job's \"reason\" field as \"UnavailableNodes\". Such nodes will typically require the intervention of a system administrator to make available. For a full list of see Job Reasons .","title":"Slurm queued reasons"},{"location":"tursa-user-guide/scheduler/#output-from-slurm-jobs","text":"Slurm places standard output (STDOUT) and standard error (STDERR) for each job in the file slurm_<JobID>.out . This file appears in the job's working directory once your job starts running. Hint Output may be buffered - to enable live output, e.g. for monitoring job status, add --unbuffered to the srun command in your SLURM script.","title":"Output from Slurm jobs"},{"location":"tursa-user-guide/scheduler/#specifying-resources-in-job-scripts","text":"You specify the resources you require for your job using directives at the top of your job submission script using lines that start with the directive #SBATCH . Hint Most options provided using #SBATCH directives can also be specified as command line options to srun . If you do not specify any options, then the default for each option will be applied. As a minimum, all job submissions must specify the budget that they wish to charge the job too with the option: --account=<budgetID> your budget ID is usually something like t01 or t01-test . You can see which budget codes you can charge to in SAFE. Other common options that are used are: --time=<hh:mm:ss> the maximum walltime for your job. e.g. For a 6.5 hour walltime, you would use --time=6:30:0 . --job-name=<jobname> set a name for the job to help identify it in In addition, parallel jobs will also need to specify how many nodes, parallel processes and threads they require. --nodes=<nodes> the number of nodes to use for the job. --tasks-per-node=<processes per node> the number of parallel processes (e.g. MPI ranks) per node. For Grid this will typically be 4 to give 1 MPI process per GPU --cpus-per-task=8 for Grid jobs where you typically use 1 MPI process per GPU, 4 per node, this will usually be 8 (so that the 32 cores on a node are evenly divided between the 4 MPI processes) --gres=gpu:4 the number of GPU to use per node. This will almost always be 4 to use all GPUs on a node Note For parallel jobs, Tursa operates in a node exclusive way. This means that you are assigned resources in the units of full compute nodes for your jobs ( i.e. 32 cores and 4 GPU) and that no other user can share those compute nodes with you. Hence, the minimum amount of resource you can request for a parallel job is 1 node (or 32 cores and 4 GPU). To prevent the behaviour of batch scripts being dependent on the user environment at the point of submission, the option --export=none prevents the user environment from being exported to the batch system. Using the --export=none means that the behaviour of batch submissions should be repeatable. We strongly recommend its use, although see the following section to enable access to the usual modules.","title":"Specifying resources in job scripts"},{"location":"tursa-user-guide/scheduler/#mpirun-launching-parallel-jobs","text":"If you are running parallel jobs, your job submission script should contain one or more mpirun commands to launch the parallel executable across the compute nodes. You will usually add the following options to mpirun : -np <number of MPI processes> : specify the number of MPI processes to launch --map-by-numa -x $LD_LIBRARY_PATH : ensure that the library paths are available to MPI processes --bind-to none","title":"mpirun: Launching parallel jobs"},{"location":"tursa-user-guide/scheduler/#example-job-submission-scripts","text":"","title":"Example job submission scripts"},{"location":"tursa-user-guide/scheduler/#example-job-submission-script-for-grid-parallel-job-using-cuda","text":"A job submission script for a Grid job that uses 4 compute nodes, 16 MPI processes per node and 4 GPUs per node: #!/bin/bash # Slurm job options (job-name, compute nodes, job time) #SBATCH --job-name=Example_Grid_job #SBATCH --time=12:0:0 #SBATCH --nodes=4 #SBATCH --tasks-per-node=4 #SBATCH --cpus-per-task=8 #SBATCH --gres=gpu:4 # Replace [budget code] below with your budget code (e.g. t01) #SBATCH --account=[budget code] # Load the correct modules module load gcc/9.3.0 module load cuda/11.4.1 module load openmpi/4.1.1-cuda11.4 ACC_THREADS=8 export OMP_NUM_THREADS=8 # Settings for MPI performance export OMPI_MCA_btl=^uct,openib export UCX_TLS=rc,rc_x,sm,cuda_copy,cuda_ipc,gdr_copy export UCX_RNDV_THRESH=16384 export UCX_RNDV_SCHEME=put_zcopy export UCX_IB_GPU_DIRECT_RDMA=yes export UCX_MEMTYPE_CACHE=n export OMPI_MCA_io=romio321 export OMPI_MCA_btl_openib_allow_ib=true export OMPI_MCA_btl_openib_device_type=infiniband export OMPI_MCA_btl_openib_if_exclude=mlx5_1,mlx5_2,mlx5_3 # These will need to be changed to match the actual application you are running application=\"my_mpi_openmp_app.x\" options=\"arg 1 arg2\" mpirun -np $SLURM_NTASKS --map-by numa -x LD_LIBRARY_PATH --bind-to none ./wrapper.sh ${application} ${options}\" This will run your executable \"grid\" in parallel usimg 16 MPI processes on 4 nodes, 8 OpenMP thread will be used per MPI process and 4 GPUs will be used per node (32 cores per node, 4 GPUs per node). Slurm will allocate 4 nodes to your job and srun will place 4 MPI processes on each node. When running on Tursa it is important that we specify how each of the GPU's interacts with the network interfaces to reach optimal network communication performance. To achieve this, we introduce a wrapper script (specified as wrapper.sh in the example job script above) that sets a number of environment parameters for each rank in a node (each GPU in a node) explicitly tell each rank which network interface it should use to communicate internode. wrapper.sh script example: #!/bin/bash lrank=$OMPI_COMM_WORLD_LOCAL_RANK numa1=$(( 2 * $lrank)) numa2=$(( 2 * $lrank + 1 )) netdev=mlx5_${lrank}:1 export CUDA_VISIBLE_DEVICES=$OMPI_COMM_WORLD_LOCAL_RANK export UCX_NET_DEVICES=mlx5_${lrank}:1 BINDING=\"--interleave=$numa1,$numa2\" echo \"`hostname` - $lrank device=$CUDA_VISIBLE_DEVICES binding=$BINDING\" numactl ${BINDING} $* See above for a more detailed discussion of the different sbatch options","title":"Example: job submission script for Grid parallel job using CUDA"},{"location":"tursa-user-guide/sw-environment/","text":"Software environment The software environment on Tursa is primarily controlled through the module command. By loading and switching software modules you control which software and versions are available to you. Information A module is a self-contained description of a software package -- it contains the settings required to run a software package and, usually, encodes required dependencies on other software packages. By default, all users on Tursa start with the default software environment loaded. Software modules on Tursa are provided by both ATOS and by EPCC. In this section, we provide: A brief overview of the module command A brief description of how the module command manipulates your environment Using the module command We only cover basic usage of the module command here. For full documentation please see the Linux manual page on modules The module command takes a subcommand to indicate what operation you wish to perform. Common subcommands are: module list [name] - List modules currently loaded in your environment, optionally filtered by [name] module avail [name] - List modules available, optionally filtered by [name] module savelist - List module collections available (usually used for accessing different programming environments) module restore name - Restore the module collection called name (usually used for setting up a programming environment) module load name - Load the module called name into your environment module remove name - Remove the module called name from your environment module swap old new - Swap module new for module old in your environment module help name - Show help information on module name module show name - List what module name actually does to your environment These are described in more detail below. Information on the available modules The module list command will give the names of the modules and their versions you have presently loaded in your environment. By default, you will have no modules loaded when you first log into Tursa Finding out which software modules are available on the system is performed using the module avail command. To list all software modules available, use: [dc-user1@tursa-login1 ~]$ module avail ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles ------------------------------------------- cuda/11.0.2 openmpi/4.1.1-cuda11.0.2 ucx/1.10.1-cuda11.0.2 ------------------------------------------- /mnt/lustre/tursafs1/apps/cuda-11.4-modulefiles -------------------------------------------- cuda/11.4.1 openmpi/4.1.1-cuda11.4 ucx/1.12.0-cuda11.4 ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.4.1-modulefiles ------------------------------------------- cuda/11.4.1 openmpi/4.1.1-cuda11.4.1 ucx/1.12.0-cuda11.4.1 ------------------------------------------------ /mnt/lustre/tursafs1/apps/modulefiles ------------------------------------------------- cuda/11.0.3 dot gcc/9.3.0 module-git module-info modules null openmpi/4.1.1 ucx/1.10.1 use.own xpmem/2.6.5 This will list all the names and versions of the modules available on the service. Not all of them may work in your account though due to, for example, licencing restrictions. You will notice that for many modules we have more than one version, each of which is identified by a version number. One of these versions is the default. As the service develops the default version will change and old versions of software may be deleted. You can list all the modules of a particular type by providing an argument to the module avail command. For example, to list all available versions of the OpenMPI library, use: [dc-user1@tursa-login1 ~]$ module avail openmpi ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles ------------------------------------------- openmpi/4.1.1-cuda11.0.2 ------------------------------------------- /mnt/lustre/tursafs1/apps/cuda-11.4-modulefiles -------------------------------------------- openmpi/4.1.1-cuda11.4 ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.4.1-modulefiles ------------------------------------------- openmpi/4.1.1-cuda11.4.1 ---------------- The module show command reveals what operations the module actually performs to change your environment when it is loaded. We provide a brief overview of what the significance of these different settings mean below. For example, for the default openmpi module: [dc-user1@tursa-login1 ~]$ module show openmpi ------------------------------------------------------------------- /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles/openmpi/4.1.1-cuda11.0.2: module-whatis Sets up OpenMPI on your environment setenv MPI_ROOT /mnt/lustre/tursafs1/apps/basestack/cuda-11.0.2/openmpi/4.1.1/ prepend-path PATH /mnt/lustre/tursafs1/apps/basestack/cuda-11.0.2/openmpi/4.1.1/bin/ prepend-path LD_LIBRARY_PATH /mnt/lustre/tursafs1/apps/basestack/cuda-11.0.2/openmpi/4.1.1/lib prepend-path MANPATH /opt/mpi/openmpi/4.0.4.1/share/man module load ucx/1.10.1 setenv OMPI_CC cc setenv OMPI_CXX g++ setenv OMPI_CFLAGS -g -m64 setenv OMPI_CXXFLAGS -g -m64 ------------------------------------------------------------------- Loading, removing and swapping modules To load a module to use the module load command. For example, to load the default version of OpenMPI into your environment, use: [dc-user1@tursa-login1 ~]$ module load openmpi UCX 1.10 loaded OpenMPI 4.1.1 loaded Once you have done this, your environment will be setup to use the OpenMPI library. The above command will load the default version of OpenMPI. If you need a specific version of the software, you can add more information: [dc-user1@tursa-login1 ~]$ module load openmpi/4.1.1-cuda11.4.1 UCX 1.12.0 compiled with cuda 11.4.1 loaded OpenMPI 4.1.1 with cuda-11.4.1 and UCX 1.12.0 loaded will load OpenMPI version 4.1.1 with CUDA 11.4.1 into your environment, regardless of the default. If you want to remove software from your environment, module rm will remove a loaded module: [dc-user1@tursa-login1 ~]$ module rm openmpi will unload what ever version of openmpi (even if it is not the default) you might have loaded. There are many situations in which you might want to change the presently loaded version to a different one, such as trying the latest version which is not yet the default or using a legacy version to keep compatibility with old data. This can be achieved most easily by using module swap oldmodule newmodule . Suppose you have loaded version 4.1.1 of openmpi , the following command will change to version 4.1.1-cuda11.4.1: [dc-user1@tursa-login1 ~]$ module swap openmpi openmpi/4.1.1-cuda11.4.1 UCX 1.12.0 compiled with cuda 11.4.1 loaded OpenMPI 4.1.1 with cuda-11.4.1 and UCX 1.12.0 loaded You did not need to specify the version of the loaded module in your current environment as this can be inferred as it will be the only one you have loaded. Capturing your environment for reuse Sometimes it is useful to save the module environment that you are using to compile a piece of code or execute a piece of software. This is saved as a module collection. You can save a collection from your current environment by executing: [dc-user1@tursa-login1 ~]$ module save [collection_name] Note If you do not specify the environment name, it is called default . You can find the list of saved module environments by executing: [dc-user1@tursa-login1 ~]$ module savelist Named collection list: 1) default To list the modules in a collection, you can execute, e.g.,: [dc-user1@tursa-login1 ~]$ module saveshow default ------------------------------------------------------------------- /home/z01/z01/dc-turn1/.module/default: module use --append /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles module use --append /mnt/lustre/tursafs1/apps/cuda-11.4-modulefiles module use --append /mnt/lustre/tursafs1/apps/cuda-11.4.1-modulefiles module use --append /mnt/lustre/tursafs1/apps/modulefilesintel module use --append /mnt/lustre/tursafs1/apps/modulefiles module load ucx/1.12.0-cuda11.4.1 module load openmpi/4.1.1-cuda11.4.1 ------------------------------------------------------------------- Note again that the details of the collection have been saved to the home directory (the first line of output above). It is possible to save a module collection with a fully qualified path, e.g., [dc-user1@tursa-login1 ~]$ module save /home/t01/z01/auser/my-module-collection if you want to save to a specific file name. To delete a module environment, you can execute: [dc-user1@tursa-login1 ~]$ module saverm <environment_name> Shell environment overview When you log in to Tursa, you are using the bash shell by default. As any other software, the bash shell has loaded a set of environment variables that can be listed by executing printenv or export . The environment variables listed before are useful to define the behaviour of the software you run. For instance, OMP_NUM_THREADS define the number of threads. To define an environment variable, you need to execute: export OMP_NUM_THREADS=4 Please note there are no blanks between the variable name, the assignation symbol, and the value. If the value is a string, enclose the string in double quotation marks. You can show the value of a specific environment variable if you print it: echo $OMP_NUM_THREADS Do not forget the dollar symbol. To remove an environment variable, just execute: unset OMP_NUM_THREADS Compiler environment The system supports the following compilers and MPI library: GCC 9.3.0 CUDA 11.4 OpenMPI 4.1.1 To compile on the system, you would typically load the required modules: [dc-user1@tursa-login1 ~]$ module load gcc/9.3.0 [dc-user1@tursa-login1 ~]$ module load cuda/11.4.1 [dc-user1@tursa-login1 ~]$ module load openmpi/4.1.1-cuda11.4 [dc-user1@tursa-login1 ~]$ module list Currently Loaded Modulefiles: 1) gcc/9.3.0 2) cuda/11.4.1 3) ucx/1.12.0-cuda11.4 4) openmpi/4.1.1-cuda11.4 Once you have loaded the modules, the standard OpenMPI compiler wrapper scripts are available: mpicc mpicxx mpif90 You can find more information on these scripts in the OpenMPI documentation .","title":"Software environment"},{"location":"tursa-user-guide/sw-environment/#software-environment","text":"The software environment on Tursa is primarily controlled through the module command. By loading and switching software modules you control which software and versions are available to you. Information A module is a self-contained description of a software package -- it contains the settings required to run a software package and, usually, encodes required dependencies on other software packages. By default, all users on Tursa start with the default software environment loaded. Software modules on Tursa are provided by both ATOS and by EPCC. In this section, we provide: A brief overview of the module command A brief description of how the module command manipulates your environment","title":"Software environment"},{"location":"tursa-user-guide/sw-environment/#using-the-module-command","text":"We only cover basic usage of the module command here. For full documentation please see the Linux manual page on modules The module command takes a subcommand to indicate what operation you wish to perform. Common subcommands are: module list [name] - List modules currently loaded in your environment, optionally filtered by [name] module avail [name] - List modules available, optionally filtered by [name] module savelist - List module collections available (usually used for accessing different programming environments) module restore name - Restore the module collection called name (usually used for setting up a programming environment) module load name - Load the module called name into your environment module remove name - Remove the module called name from your environment module swap old new - Swap module new for module old in your environment module help name - Show help information on module name module show name - List what module name actually does to your environment These are described in more detail below.","title":"Using the module command"},{"location":"tursa-user-guide/sw-environment/#information-on-the-available-modules","text":"The module list command will give the names of the modules and their versions you have presently loaded in your environment. By default, you will have no modules loaded when you first log into Tursa Finding out which software modules are available on the system is performed using the module avail command. To list all software modules available, use: [dc-user1@tursa-login1 ~]$ module avail ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles ------------------------------------------- cuda/11.0.2 openmpi/4.1.1-cuda11.0.2 ucx/1.10.1-cuda11.0.2 ------------------------------------------- /mnt/lustre/tursafs1/apps/cuda-11.4-modulefiles -------------------------------------------- cuda/11.4.1 openmpi/4.1.1-cuda11.4 ucx/1.12.0-cuda11.4 ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.4.1-modulefiles ------------------------------------------- cuda/11.4.1 openmpi/4.1.1-cuda11.4.1 ucx/1.12.0-cuda11.4.1 ------------------------------------------------ /mnt/lustre/tursafs1/apps/modulefiles ------------------------------------------------- cuda/11.0.3 dot gcc/9.3.0 module-git module-info modules null openmpi/4.1.1 ucx/1.10.1 use.own xpmem/2.6.5 This will list all the names and versions of the modules available on the service. Not all of them may work in your account though due to, for example, licencing restrictions. You will notice that for many modules we have more than one version, each of which is identified by a version number. One of these versions is the default. As the service develops the default version will change and old versions of software may be deleted. You can list all the modules of a particular type by providing an argument to the module avail command. For example, to list all available versions of the OpenMPI library, use: [dc-user1@tursa-login1 ~]$ module avail openmpi ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles ------------------------------------------- openmpi/4.1.1-cuda11.0.2 ------------------------------------------- /mnt/lustre/tursafs1/apps/cuda-11.4-modulefiles -------------------------------------------- openmpi/4.1.1-cuda11.4 ------------------------------------------ /mnt/lustre/tursafs1/apps/cuda-11.4.1-modulefiles ------------------------------------------- openmpi/4.1.1-cuda11.4.1 ---------------- The module show command reveals what operations the module actually performs to change your environment when it is loaded. We provide a brief overview of what the significance of these different settings mean below. For example, for the default openmpi module: [dc-user1@tursa-login1 ~]$ module show openmpi ------------------------------------------------------------------- /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles/openmpi/4.1.1-cuda11.0.2: module-whatis Sets up OpenMPI on your environment setenv MPI_ROOT /mnt/lustre/tursafs1/apps/basestack/cuda-11.0.2/openmpi/4.1.1/ prepend-path PATH /mnt/lustre/tursafs1/apps/basestack/cuda-11.0.2/openmpi/4.1.1/bin/ prepend-path LD_LIBRARY_PATH /mnt/lustre/tursafs1/apps/basestack/cuda-11.0.2/openmpi/4.1.1/lib prepend-path MANPATH /opt/mpi/openmpi/4.0.4.1/share/man module load ucx/1.10.1 setenv OMPI_CC cc setenv OMPI_CXX g++ setenv OMPI_CFLAGS -g -m64 setenv OMPI_CXXFLAGS -g -m64 -------------------------------------------------------------------","title":"Information on the available modules"},{"location":"tursa-user-guide/sw-environment/#loading-removing-and-swapping-modules","text":"To load a module to use the module load command. For example, to load the default version of OpenMPI into your environment, use: [dc-user1@tursa-login1 ~]$ module load openmpi UCX 1.10 loaded OpenMPI 4.1.1 loaded Once you have done this, your environment will be setup to use the OpenMPI library. The above command will load the default version of OpenMPI. If you need a specific version of the software, you can add more information: [dc-user1@tursa-login1 ~]$ module load openmpi/4.1.1-cuda11.4.1 UCX 1.12.0 compiled with cuda 11.4.1 loaded OpenMPI 4.1.1 with cuda-11.4.1 and UCX 1.12.0 loaded will load OpenMPI version 4.1.1 with CUDA 11.4.1 into your environment, regardless of the default. If you want to remove software from your environment, module rm will remove a loaded module: [dc-user1@tursa-login1 ~]$ module rm openmpi will unload what ever version of openmpi (even if it is not the default) you might have loaded. There are many situations in which you might want to change the presently loaded version to a different one, such as trying the latest version which is not yet the default or using a legacy version to keep compatibility with old data. This can be achieved most easily by using module swap oldmodule newmodule . Suppose you have loaded version 4.1.1 of openmpi , the following command will change to version 4.1.1-cuda11.4.1: [dc-user1@tursa-login1 ~]$ module swap openmpi openmpi/4.1.1-cuda11.4.1 UCX 1.12.0 compiled with cuda 11.4.1 loaded OpenMPI 4.1.1 with cuda-11.4.1 and UCX 1.12.0 loaded You did not need to specify the version of the loaded module in your current environment as this can be inferred as it will be the only one you have loaded.","title":"Loading, removing and swapping modules"},{"location":"tursa-user-guide/sw-environment/#capturing-your-environment-for-reuse","text":"Sometimes it is useful to save the module environment that you are using to compile a piece of code or execute a piece of software. This is saved as a module collection. You can save a collection from your current environment by executing: [dc-user1@tursa-login1 ~]$ module save [collection_name] Note If you do not specify the environment name, it is called default . You can find the list of saved module environments by executing: [dc-user1@tursa-login1 ~]$ module savelist Named collection list: 1) default To list the modules in a collection, you can execute, e.g.,: [dc-user1@tursa-login1 ~]$ module saveshow default ------------------------------------------------------------------- /home/z01/z01/dc-turn1/.module/default: module use --append /mnt/lustre/tursafs1/apps/cuda-11.0.2-modulefiles module use --append /mnt/lustre/tursafs1/apps/cuda-11.4-modulefiles module use --append /mnt/lustre/tursafs1/apps/cuda-11.4.1-modulefiles module use --append /mnt/lustre/tursafs1/apps/modulefilesintel module use --append /mnt/lustre/tursafs1/apps/modulefiles module load ucx/1.12.0-cuda11.4.1 module load openmpi/4.1.1-cuda11.4.1 ------------------------------------------------------------------- Note again that the details of the collection have been saved to the home directory (the first line of output above). It is possible to save a module collection with a fully qualified path, e.g., [dc-user1@tursa-login1 ~]$ module save /home/t01/z01/auser/my-module-collection if you want to save to a specific file name. To delete a module environment, you can execute: [dc-user1@tursa-login1 ~]$ module saverm <environment_name>","title":"Capturing your environment for reuse"},{"location":"tursa-user-guide/sw-environment/#shell-environment-overview","text":"When you log in to Tursa, you are using the bash shell by default. As any other software, the bash shell has loaded a set of environment variables that can be listed by executing printenv or export . The environment variables listed before are useful to define the behaviour of the software you run. For instance, OMP_NUM_THREADS define the number of threads. To define an environment variable, you need to execute: export OMP_NUM_THREADS=4 Please note there are no blanks between the variable name, the assignation symbol, and the value. If the value is a string, enclose the string in double quotation marks. You can show the value of a specific environment variable if you print it: echo $OMP_NUM_THREADS Do not forget the dollar symbol. To remove an environment variable, just execute: unset OMP_NUM_THREADS","title":"Shell environment overview"},{"location":"tursa-user-guide/sw-environment/#compiler-environment","text":"The system supports the following compilers and MPI library: GCC 9.3.0 CUDA 11.4 OpenMPI 4.1.1 To compile on the system, you would typically load the required modules: [dc-user1@tursa-login1 ~]$ module load gcc/9.3.0 [dc-user1@tursa-login1 ~]$ module load cuda/11.4.1 [dc-user1@tursa-login1 ~]$ module load openmpi/4.1.1-cuda11.4 [dc-user1@tursa-login1 ~]$ module list Currently Loaded Modulefiles: 1) gcc/9.3.0 2) cuda/11.4.1 3) ucx/1.12.0-cuda11.4 4) openmpi/4.1.1-cuda11.4 Once you have loaded the modules, the standard OpenMPI compiler wrapper scripts are available: mpicc mpicxx mpif90 You can find more information on these scripts in the OpenMPI documentation .","title":"Compiler environment"}]}